\documentclass[serif,mathserif]{article}
\usepackage[utf8x]{inputenc}
\usepackage{comment}
\usepackage[portuges]{babel}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{dcolumn}
\usepackage{hyperref}
\lstloadlanguages{Ruby}
\lstdefinelanguage{Smalltalk}{ 
  morekeywords={true,false,self,super,nil}, 
  sensitive=true, 
  morecomment=[s]{"}{"}, 
  morestring=[d]', 
  style=SmalltalkStyle 
} 
\lstdefinestyle{SmalltalkStyle}{ 
  literate={:=}{{$\gets$}}1{^}{{$\uparrow$}}1 
}

\author{ 
    \\ Rodrigo di Lorenzo Lopes \\  \texttt{rodrigo.lorenzo@abril.com.br}
	\and 
    \\ Celestino Ferreira Gomes \\ \texttt{contato@tinogomes.com}
}
\title{Curso: Ruby Básico}

\begin{document}
\maketitle
 
\tableofcontents

\section{Introducao: Ruby.new}

\subsection{Ideia do Curso}

\begin{itemize}
  \item Apresentar a linguagem
  \item Técnicas de metaprogramação
  \item Problemas e desafios
\end{itemize}

\subsection{Sobre Ruby}
Ruby é uma linguagem de programação \em{interpretada}, de \em{tipagem dinâmica} e \em{forte}, com \em{gerenciamento de memória automático}, originalmente planejada e desenvolvida no Japão em 1995, por Yukihiro "Matz" Matsumoto, para ser usada como linguagem de script.

Matz queria uma linguagem de script que fosse mais poderosa do que Perl, e mais orientada a objetos do que Python. Ruby é primariamente, uma linguagem \em{orientada a objetos}, mas suporta outros paradigmas de programação, como \em{funcional}, \em{imperativa}  e \em{reflexiva}.

Foi inspirada principalmente por Python, Perl, Smalltalk, Eiffel, Ada e Lisp, sendo muito similar em vários aspectos a Python.

fonte: \href{http://bit.ly/wiki-ruby}{Wikipedia - http://bit.ly/wiki-ruby}

\subsection{Ruby.new}

\begin{itemize}
\item Linguagem para humanos
\item Compare:
\begin{lstlisting}[language=ruby]
5.times { print "Ola!" }
\end{lstlisting}

\begin{lstlisting}[language=java]
for (int i=0; i <10; i++) { printf("Ola!");}
\end{lstlisting}

\end{itemize}

\subsection{O que faz o código a seguir?}
\begin{lstlisting}[language=java]
   exit unless "restaurante".include? "aura"
   ['toasty', 'cheese', 'wine'].each 
        { |food| print food.capitalize }
\end{lstlisting}


\section{Estruturas básicas}

\begin{itemize}
  \item Variáveis 
\begin{lstlisting}[language=ruby]
x, y, taxa_do_lixo2
\end{lstlisting} 
   \item{Numeros}
\begin{lstlisting}[language=ruby]
1, -1.2, 6.03e-23    
\end{lstlisting}
	\item {String}
\begin{lstlisting}[language=ruby]
"alguma coisa assim"
%q(veremos outras formas de declarar strings)
\end{lstlisting}
 
\end{itemize}

\begin{itemize}
  \item Symbols
% * Symbols
\begin{lstlisting}[language=ruby]
:x, :y, :isso_parece_uma_string
\end{lstlisting}

  \item Constantes 
\begin{lstlisting}[language=ruby]  
EmpireStateBuilding, NEA, PI
\end{lstlisting}

  \item Objetos especiais 
\begin{lstlisting}[language=ruby]
true, false, nil
\end{lstlisting}
\end{itemize}

Símbolos são alocados uma única vez: :a.object\_id durante uma execução sempre
retornara o mesmo valor. Isso nao acontece com string. O método equal? so
devolve true se dois objetos são de fato o mesmo objeto (e instâncias da mesma
classe com valores iguais).

\subsection{Métodos (mensagens)}
\begin{lstlisting}[language=ruby]
i = 1        
texto = "um texto"; puts texto
a = b = c = 0
1 == 2           # sugar syntax!!!
# metodo de classe
1.methods  # lista todos os metodos daquele objeto
1.send(:even?) # outra forma de enviar mensagens
def fibo(n = 1)
    fibo(n-2) + fibo(n-1) if n >= 2
end
def self.log
  puts "metodo de classe"
end
\end{lstlisting}

Lembre-se ... voce pode redefinir um método
Quase tudo e objeto

\subsection{Estruturas de Controle - if}
 
       
\subsection {Exemplo Completo}
\begin{lstlisting}[language=ruby]
if count > 10
  puts "Try again"
elsif tries == 3
  puts "You lose"
  puts  Number:"
end
\end{lstlisting}

\subsection {Exemplo Simples}
\begin{lstlisting}[language=ruby]
if radiation > 3000
  puts "Danger"
end
\end{lstlisting}

\subsection {Modificador de Sentenca}
\begin{lstlisting}[language=ruby]
puts "Danger, Will Robinson" if radiation > 3000
\end{lstlisting}

\subsection{Estruturas de Controle - case} 
\begin{lstlisting}[language=ruby]
print "Enter your grade: "
grade = gets.chomp
case grade
when "A"
  puts 'Well done!'
when "B"
  puts 'Try harder!'
when "C", "D"
  puts 'You need help!!!'
  puts "You just making it up!"
 end
\end{lstlisting}


\subsection{Estruturas de Controle - while}
\begin{lstlisting}[language=ruby]
while weight < 100 and numPallets <= 30
  pallet = nextPallet()
  weight += pallet.weight
  numPallets += 1
end
\end{lstlisting}
 
\subsection {Modificador de Sentenca}
\begin{lstlisting}[language=ruby]
square = square*square  while square < 1000
\end{lstlisting}

\subsection{Estrutura de Controle -  for}
\begin{lstlisting}[language=ruby]
for i in 0..5
   puts "Value is #{i}"
end
\end{lstlisting}

\subsection{Estrutura de Controle -  until} 
\begin{lstlisting}[language=ruby]
until weight >= 100 ||numPallets > 30
  pallet = nextPallet()
  weight += pallet.weight
  numPallets += 1
end
\end{lstlisting}

\subsection {Modificador de Sentenca}
\begin{lstlisting}[language=ruby]
square = square*square  until square >= 1000
\end{lstlisting}

\subsection{Desafio - FizzBuzz}  
Escreva um programa que imprima o número de 1 a 100.
Mas, para múltiplos de três, imprima  ``Fizz'' no lugar do
número e para múltiplos de cinco imprima ``Buzz''. Para
números que são múltiplos de ambos três e cinco
imprima ``FizzBuzz''.
 
\url{http://www.rubyquiz.com/quiz126.html}

\subsection{Solução FizzBuzz}

\lstinputlisting[language=ruby]{../Exemplos/1-very_basic/fizzbuzz.rb}

\section{Containers}

\subsection{Array}
\begin{lstlisting}[language=ruby]
a = [ 3.14159, "pie", 99 ]
a.type   #        Array
a.length #        3
a[0]     #        3.14159
a << 1
a[3]     #        1
a[-2]    #        99
b = Array.new
b << a   #   [[3.14159, "pie", 99, 1]]
b[0..3] = a    #   [3.14159, "pie", 99, 1]
b[0, 2] = 1    #   [1, 1]
c = %w{a b c d e }  #  =>  ["a", "b", "c", "d"]
\end{lstlisting}


\subsection{Hash}
\begin{lstlisting}[language=ruby]
h = {'dog' => 'canine', 'cat' => 'feline', 'donkey' => 'asinine'}
h.length        #        3
h['dog']        #        "canine"
h['cow'] = 'bovine'
h[12]    = 'dodecine'
h['cat'] = 99
h        # => {"cow"=>"bovine", "cat"=>99, 12=>"dodecine",
"donkey"=>"asinine", "dog"=>"canine"}
  
a = [[1, 'a'],[2, 'b'],[3, 'c'], [4, 'd']]
b = Hash[a]
# => {1=>"a", 2=>"b", 3=>"c", 4=>"d"}
\end{lstlisting}


\subsection{Blocos e Iteradores}

Passando blocos
\begin{lstlisting}[language=ruby]
(1..12).each { |i| puts i}
[1, 2, 4].each do |i|
    puts i
end
\end{lstlisting}

Blocos de código
\begin{lstlisting}[language=ruby]
(1..20).each{|x| puts x}
\end{lstlisting}

Influência do Smalltalk:
\begin{lstlisting}[language=smalltalk]
   1 to: 20 do: [:x | x printN1]
\end{lstlisting}

\subsection{ Métodos de um Enumerable}
\begin{lstlisting}  
all?, any?, collect, detect, each_cons, each_slice, each_with_index, entries,
enum_cons, enum_slice, enum_with_index, find, find_all, grep, include?, inject,
map, max, member?, min, partition, reject, select, sort, sort_by, to_a,
to_set, zip
\end{lstlisting}
 
\subsection{Exemplos com Enumeraveis}
\begin{lstlisting}[language=ruby]
names = %w{ Frye Leela Zoidberg }
names.find {|name|  name.length>4}          # => "Leela"
names.find_all { |name| name.length > 4}
     #=> ["Leela", "Zoidberg"]
names.grep /oidberg/
# => ["Zoidberg"]
names.group_by {|name|  name.length}
   # =>  {4=>["Frye"], 5=>["Leela"], 8=>["Zoidberg"]}
\end{lstlisting}

\subsection{Mais exemplos com Enumeraveis}
\begin{lstlisting}[language=ruby]
names = %w{ Frye Leela Zoidberg }
names.map {|name| name.downcase}
# => ["frye", "leela", "zoidberg"]
names.reduce {|acc, name| name.length <= 5 ? acc + name : acc }
# => "FryeLeela"
names.join ", "
# => "Frye, Leela, Zoidberg"
\end{lstlisting}


\section{Blocos}

\subsection{yield}
\begin{lstlisting}[language=ruby]
def proxy_method
  puts "Calling command at: #{Time.new}"
  yield
proxy_method { puts "hello world proxified! "}
#ou com paremtros
def proxy_method
   yield(Time.new)
proxy_method {|time| puts "hello world proxified  at #{time}"}
\end{lstlisting}

\subsection{call}
\begin{lstlisting}[language=ruby]
def proxy_method(&method)
  # argumento com & precisa ser o ultimo da lista
  puts "Calling command at: #{Time.new}"
  method.call
proxy_method { puts "hello world proxified! "}
#ou com paremtros
def proxy_method (&method)
   method.call(Time.new)
proxy_method {|time| puts "hello world proxified  at #{time}"}
\end{lstlisting}

\subsection{Proc x Lambda}
\begin{lstlisting}[language=ruby]
fx = Proc.new {|x| x**2}
fxy = proc {|x,y| x+y}
# calling
fx.call(2) # => 4
fxy[2,3,4] #=> 5
fx = lambda {|x| x**2}
fxy = lambda {|x,y| x+y}
# calling
fx.call(2) # => 4
fxy.call(2,3,4) #=> exception na cara!
Proc.new e proc sao equivalentes
\end{lstlisting}


\subsection{Lambda ``Calculus''}

\begin{lstlisting}[language=ruby, caption="Derivada em Ruby"]
def d(f)
   lambda {|a|
     h = 0.0000000001 # um valor pequeno para h
     h = h * a       if a < 1 && 0 < a
     (f[a+h]-f[a])/h
   }
f = lambda {|x| x**2}
puts d(f)[4]
\end{lstlisting}

\section{Objetos em Ruby}
\begin{lstlisting}[language=ruby]
class BookInStock
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
 
  def to_s
    "ISBN:#{@isbn}, price: #{@price}"
  end
end
stock = BookInStock.new
# ou
stock = BookInStock.new (1234, 10.39)
#invocando metodo
puts stock.to_s
\end{lstlisting}


\subsection{Variaveis e Escopo}

\begin{tabular}{ l | c | r }
Variáveis Locais & \verb|x name thx1138 _x _26| \\
Variáveis de Instancia & \verb|@name @X  @_ @plan9| \\
Variáveis de Classe & \verb|@@total @@N @@x_pos| \\
Variáveis Globais & \verb|$debug $CUSTOM $_ $plan9| \\
Nomes de Classe & \verb|String BigDecimal| \\
Constants & \verb|FEET_PER_MILE DEBUG|
\end{tabular}

\subsection{Atributos de instância - forma tradicional}
\begin{lstlisting}[language=ruby]
class BookInStock  
  def isbn
    @isbn
  end
 
  def isbn=(value)
    @isbn = value
  end
 
  def price
    @price
  end
\end{lstlisting}

\subsection{Atributos de instância - forma declarativa}
\begin{lstlisting}[language=ruby]
class BookInStock  
  attr_accessor :isbn
  attr_reader :price
 end
\end{lstlisting}

\subsection{Herança}
\subsubsection{Exemplo de Heranca}
\begin{lstlisting}[language=ruby]
class SpecialStock < BookInStock
\end{lstlisting}

\subsection{Herança - Singleton Pattern}

\subsubsection{forma tradicional}
\begin{lstlisting}[language=ruby]
class Logger
  private_class_method :new
  @@logger = nil
  def Logger.create
    @@logger = new unless @@logger
    @@logger
  end
end
\end{lstlisting}

\subsubsection{módulo Singleton}
\begin{lstlisting}[language=ruby]
require 'singleton'
class Logger
  include Singleton
  
  def initialize
    @log = File.open("log.txt", "a")
  end
  def log(msg)
    @log.puts(msg)
  end
Logger.instance.log('message 2')
\end{lstlisting}

\begin{lstlisting}[language=ruby]
stock =  BookInStock.new
class << stock
   def alter_price
         price * 1.4
   end
\end{lstlisting}

\subsection{Criando um Enumerable}
  *  Basta implementar o metodo each. 
\begin{lstlisting}[language=ruby]
class Node
  include Enumerable 
  attr_accessor :next, :previous, :v
 def initialize(v = {})
    @v = v
  end
 def to_s
    v.to_s
  end
\end{lstlisting}

\begin{lstlisting}[language=ruby]
linked_list.rb (continuacao)
 def <<(node)
    node.next = self.next
    node.previous = self
    self.next.previous = node unless self.next.nil?
    self.next = node
  end
 def remove
    node = self.previous
    node.next = self.next
    self.next.previous = node
    self
 end
\end{lstlisting}

\begin{lstlisting}[language=ruby]
  def each
    node = self.next
    until node == self || node.nil?
      yield node
      node = node.next
    end
  end

\end{lstlisting}



\section{Mais sobre métodos}

\subsection{Lista de parâmetros}

\begin{lstlisting}[language=ruby]
def my_new_method               # No arguments
  # Code for the method would go here
end

def my_other_new_method(arg1, arg2, arg3)  # 3 arguments
  # Code for the method would go here
end

def cool_dude(arg1="Miles", arg2="Coltrane", arg3="Roach")  # defaults
  "#{arg1}, #{arg2}, #{arg3}."
end
\end{lstlisting}

\subsection{Truques com parâmetros}

Aridade não definida

\begin{lstlisting}[language=ruby]
def varargs(arg1, *rest)
  "Got #{arg1} and #{rest.join(', ')}"

varargs("one")  # "Got one and "
varargs("one", "two") # "Got one and two"
varargs "one", "two", "three" # "Got one and two, three"

def varargs(arg1, hash)
 puts "#{arg1} - #{hash}"
end

varargs (1, :a => 1)
end
\end{lstlisting}

\subsection{Array para argumentos}

Expandindo array para parâmetros

\begin{lstlisting}[language=ruby]
def five(a, b, c, d, e)
  "I was passed #{a} #{b} #{c} #{d} #{e}"
end

five(1, 2, 3, 4, 5 )         #  "I was passed 1 2 3 4 5"
five(1, 2, 3, *['a', 'b'])  # "I was passed 1 2 3 a b"
five(*(10..14).to_a)         #  "I was passed 10 11 12 13 14"
\end{lstlisting}

\subsection{Proc para bloco}

Convertendo proc para bloco

\begin{lstlisting}[language=ruby]
print "(t)imes or (p)lus: "
times = gets.chomp
print "number: "
number = gets.to_i

if times =~ /^t/
  calc = proc { |n| n*number }
else
  calc = proc { |n| n+number }
end

puts((1..10).collect(&calc).join(", "))
\end{lstlisting}

\section{Exceptions, Catch and Throw}

\begin{lstlisting}[language=ruby]
opFile = File.open(opName, "w")

while data = socket.read(512)
  opFile.write(data)
end
\end{lstlisting}

\subsection{Exceptions}

\begin{lstlisting}[language=ruby]
opFile = File.open(opName, "w")
begin
  # Exceptions raised by this code will
  # be caught by the following rescue clause
  while data = socket.read(512)
    opFile.write(data)
  end

rescue SystemCallError
  $stderr.print "IO failed: " + $!
  opFile.close
  File.delete(opName)
  raise
end
\end{lstlisting}

\subsection{Catching exception}

Nomeando a exceção

\begin{lstlisting}[language=ruby]

begin
  eval string
rescue SyntaxError, NameError => boom
  # OLHA! sem usar o $!
  print "String doesn't compile: " + boom
rescue StandardError => bang
  print "Error running script: " + bang
end
\end{lstlisting}

\subsection{Ensure}

Garante que um bloco é chamado

\begin{lstlisting}[language=ruby]

f = File.open("testfile")
begin
  # .. process
rescue
  # .. handle error
ensure
  f.close unless f.nil?
end
\end{lstlisting}

\subsection{Rescuing a Method}

Begin Rescue

\begin{lstlisting}[language=ruby]

def some_method
  begin
    danger_danger
    true # good return
  rescue Error
    false # error return
  end
end
\end{lstlisting}

Better code

\begin{lstlisting}[language=ruby]

def some_method
  danger_danger
  true # good response
rescue Error
  false # error response
end
\end{lstlisting}

\subsection{Raise Exceptions}

Formas típicas de se lançar uma exceção

\begin{lstlisting}[language=ruby]

 raise # sem mensagem

 # adicionando uma string...
 raise "Missing name" if name.nil?

 if i >= myNames.size
   raise IndexError, "#{i} >= size (#{myNames.size})"
 end

 # passando o stackTrace via Kernel::caller
 raise ArgumentError, "Name too big", caller
\end{lstlisting}

\subsection{Especializando Exceções}

Declaração

\begin{lstlisting}[language=ruby]

class RetryException < RuntimeError
  attr :okToRetry

  def initialize(okToRetry)
    @okToRetry = okToRetry
  end
end
\end{lstlisting}

Como lançar

\begin{lstlisting}[language=ruby]

def readData(socket)
  data = socket.read(512)
  if data.nil?
    raise RetryException.new(true), "transient read error"
  end
  # .. normal processing
end
\end{lstlisting}

\subsection{Especializando Exceções II}

Tratanto a exceção

\begin{lstlisting}[language=ruby]

begin
  stuff = readData(socket)
  # .. process stuff
rescue RetryException => detail
  retry if detail.okToRetry
  raise
end
\end{lstlisting}

\subsection{Catch e Throw}

Desvio incondicional com labels

\begin{lstlisting}[language=ruby]

def promptAndGet(prompt)
  print prompt
  res = readline.chomp
  throw :quitRequested if res == "!"
  return res
end

catch :quitRequested do
  name = promptAndGet("Name: ")
  age  = promptAndGet("Age:  ")
  sex  = promptAndGet("Sex:  ")
  # ..
  # process information
end
\end{lstlisting}

\section{Módulos}
Uso

\begin{enumerate}
  \item Criar namespace (evitar conflito de nomes)
  \item Mixin (permitir herança de traços – como se fosse uma cópia do conteúdo do módulo no local incluído)
\end{enumerate}

\subsection{Declaração}

\begin{lstlisting}[language=ruby]

module Trig
  PI = 3.141592654
  def Trig.sin(x)
   # ..
  end
  def Trig.cos(x)
   # ..
  end
end
\end{lstlisting}

\subsubsection{Uso}

\begin{lstlisting}[language=ruby]

require "./trig"
puts Trig.sin(Trig::PI / 3.0)
\end{lstlisting}

\subsection{Mixins}

Applying mixin

\begin{lstlisting}[language=ruby]

class BigInteger < Number
  # Adiciona metodos de instancia de Stringify
  include Stringify

  # Adiciona metodos de classe de Math
  extend Math

  # Adiciona um constructor com um parametro
  def initialize(value)
    @value = value
  end
end
\end{lstlisting}

\subsection{Applying mixin}

\begin{lstlisting}[language=ruby]

bigint1 = BigInteger.new(10)

puts bigint1.intValue   # --> 10

bigint2 = BigInteger.add(-2, 4)
puts bigint2.intValue   # --> 2

puts bigint2.stringify   # --> 'Two'

bigint2.extend CurrencyFormatter
\end{lstlisting}

\section{Pacotes Básicos}

\subsection{BigDecimal}

\begin{lstlisting}[language=ruby]

require 'bigdecimal'

BigDecimal.new('1.23) # => #<BigDecimal:7ffe0b052bc8,'0.123E1',18(18)>
\end{lstlisting}

\subsection{OpenStruct}

\begin{lstlisting}[language=ruby]
require 'ostruct'
\end{lstlisting}

\subsection{Test}

\begin{lstlisting}[language=ruby]

require "test/unit"

class TesteFoo  < Test::Unit::TestCase

  def test_eFoo_foo
    assert_same(1, 0, "Que pena")
  end
end
\end{lstlisting}

\subsection{ERB}

\begin{itemize}
  \item Sistema de Template padrão do Ruby
  \item Uma classe como outra qualquer
  \item Via linha de comando é possível parsear um arquivo erb
\end{itemize}

\begin{lstlisting}[language=ruby]
require 'erb'

template = ERB.new('1 + 1 = <%= 1 + 1 %>')
template.result # => '1 + 1 = 2'
\end{lstlisting}

\subsection{Net::HTTP}

\begin{lstlisting}[language=ruby]
	require "net/http"
	require "uri"
	require 'methodize'
	
	def get_page (string)
	  uri = URI.parse(string)
	  response = Net::HTTP.get_response(uri)
	  response.body
	end
\end{lstlisting}

\subsection{JSON}

\begin{lstlisting}[language=ruby]
	require "net/http"
	require "uri"
	require 'json'
	require 'methodize'
	
	def get_page (string)
	  uri = URI.parse(string)
	  response = Net::HTTP.get_response(uri)
	  json = JSON.parse(response.body)
	  json.extend(Methodize)
	end
\end{lstlisting}

\subsection{YAML}

\subsubsection{Arquivo yaml}

\begin{verbatim}
	simple symbol: !ruby/symbol Simple 
	shortcut syntax: !ruby/sym Simple 
	symbols in seqs: 
	  - !ruby/symbol ValOne 
	  - !ruby/symbol ValTwo 
	  - !ruby/symbol ValThree 
	symbols in maps: 
	  - !ruby/symbol MapKey: !ruby/symbol MapValue 
\end{verbatim}

\subsubsection{Ruby code}

\begin{lstlisting}[language=ruby]
	require "yaml"
	
	config = YAML.load_file("config.yml") # From file
	p config
\end{lstlisting}

\subsubsection{Result}

\begin{verbatim}
{"simple symbol"=>:Simple, "shortcut syntax"=>:Simple, 
"symbols in seqs"=>[:ValOne, :ValTwo, :ValThree], 
"symbols in maps"=>[{:MapKey=>:MapValue}]}
\end{verbatim}

\end{document}
