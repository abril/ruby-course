\documentclass[serif,mathserif]{article}
\usepackage[utf8x]{inputenc}
\usepackage{comment}
\usepackage[portuges]{babel}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{xcolor}
\usepackage{bashful}
\usepackage{dcolumn}
\usepackage{hyperref}
\usepackage[stable]{footmisc}

\lstset{%
    	extendedchars=true,
    	inputencoding=utf8/latin1,
        literate=%
        {é}{{\'{e}}}1
        {è}{{\`{e}}}1
        {ê}{{\^{e}}}1
        {ë}{{\¨{e}}}1
        {É}{{\'{E}}}1
        {Ê}{{\^{E}}}1
        {û}{{\^{u}}}1
        {ú}{{\'{u}}}1        
        {ù}{{\`{u}}}1
        {â}{{\^{a}}}1
        {à}{{\`{a}}}1 
        {á}{{\'{a}}}1
        {ã}{{\~{a}}}1
        {Á}{{\'{A}}}1
        {Â}{{\^{A}}}1
        {Ã}{{\~{A}}}1
        {ç}{{\c{c}}}1
        {Ç}{{\c{C}}}1
        {õ}{{\~{o}}}1
        {ó}{{\'{o}}}1
        {ô}{{\^{o}}}1
        {Õ}{{\~{O}}}1
        {Ó}{{\'{O}}}1
        {Ô}{{\^{O}}}1
        {î}{{\^{i}}}1
        {Î}{{\^{I}}}1
        {í}{{\'{i}}}1
        {Í}{{\~{Í}}}1
}

\lstloadlanguages{Ruby}
\lstdefinelanguage{Smalltalk}{ 
  morekeywords={true,false,self,super,nil}, 
  sensitive=true, 
  morecomment=[s]{"}{"}, 
  morestring=[d]', 
  style=SmalltalkStyle 
} 
\lstdefinestyle{BashInputStyle}{
  language=bash,
  numbers=none,  
  basicstyle=\small\sffamily,
  frame=tb,
  columns=fullflexible,
  backgroundcolor=\color{yellow!20},
  % linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth
}

\lstdefinestyle{BashOutputStyle}{
  basicstyle=\small\ttfamily,
  numbers=none,
  frame=tblr,
  columns=fullflexible,
  backgroundcolor=\color{blue!10},
  % linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth
}

\lstdefinestyle{SmalltalkStyle}{ 
  literate={:=}{{$\gets$}}1{^}{{$\uparrow$}}1 
}

\newcommand*{\Package}[1]{\texttt{#1}}%

\author{ 
    \\ Rodrigo di Lorenzo Lopes \\  \texttt{rodrigo.lorenzo@abril.com.br}
	\and 
    \\ Celestino Ferreira Gomes \\ \texttt{contato@tinogomes.com}
}
\title{Curso: Ruby Básico}

\begin{document}
\maketitle
 
\tableofcontents

\section{Introducao: Ruby.new}

\subsection{Ideia do Curso}

\begin{itemize}
  \item Apresentar a linguagem
  \item Técnicas de metaprogramação
  \item Problemas e desafios
\end{itemize}

\subsection{Sobre Ruby}
Ruby é uma linguagem de programação \em{interpretada}, de \em{tipagem dinâmica} e \em{forte}, com \em{gerenciamento de memória automático},
 originalmente planejada e desenvolvida no Japão em 1995, por Yukihiro "Matz" Matsumoto, para ser usada como linguagem de script.

Matz queria uma linguagem de script que fosse mais poderosa do que Perl, e mais orientada a objetos do que Python.
Ruby é primariamente, uma linguagem \em{orientada a objetos}, mas suporta outros paradigmas de programação,
como \em{funcional}, \em{imperativa}  e \em{reflexiva}.

Foi inspirada principalmente por Python, Perl, Smalltalk, Eiffel, Ada e Lisp, sendo muito similar em vários aspectos a Python.

fonte: \href{http://bit.ly/wiki-ruby}{Wikipedia - http://bit.ly/wiki-ruby}

\subsection{Inslatação}
Antes de prosseguir com o curso, vejamos como instalar o interpretador da linguagem. Ruby é hoje portado para os principais sistemas operacionais:

\subsubsection{Windows}

Baixar o executável de instalação em \url{http://rubyinstaller.org/downloads/}

\subsubsection{Linux (Debian / Ubuntu)}

\begin{lstlisting}[style=BashInputStyle]
$ [sudo] apt-get install ruby1.9.1
\end{lstlisting}

\subsubsection{Mac (via Homebrew)\footnote{Linux e Mac normalmente já vem com uma instalação de Ruby.}}

\begin{lstlisting}[style=BashInputStyle]
$ brew install ruby
\end{lstlisting}

Podemos verificar a versão já instalada do Ruby que está no \Package{PATH}.

Verificar a versão de ruby instalada, digite  \Package{ruby --version}.

\begin{lstlisting}[style=BashInputStyle]
$ ruby --version
\end{lstlisting}

Você receberá uma mensagem como essa:
\begin{lstlisting}[style=BashOutputStyle]
ruby 1.9.3p374 (2013-01-15 revision 38858) [x86_64-darwin10.8.0]
\end{lstlisting}

\Package{ruby -v} também imprime a versão do ruby, porém ativa o modo \em{verbose} e permite executar scripts.

O código-fonte ruby é um arquivo de texto como qualquer outro. Você pode utilizar seu editor de texto favorito, mas aqui a lista dos principais editores e IDEs
disponíveis para a linguagem: 

\begin{itemize}
  \item \href{http://www.sublimetext.com/2}{Sublime Text 2}
\item \href{http://www.vim.org/}{Vim}
\item \href{http://www.gnu.org/software/emacs/}{Emacs}
\item \href{https://github.com/textmate/textmate/}{TextMate 2 (Mac)}
\item \href{https://netbeans.org/downloads/6.9.1/index.html}{Netbeans 6.9.1}
\item \href{http://www.aptana.com/}{Aptana}
\end{itemize}

 

\subsection{Ruby.new}

Ao longo desse curso, veremos comos os paradigmas de programação são aplicados em Ruby. Por enquanto, para exemplificar o pardigma orienta-a-objetos,
observe o exemplo:

\begin{lstlisting}[language=ruby]
5.times { print "Ola!" }
\end{lstlisting}

\begin{lstlisting}[language=java]
for (int i=0; i <10; i++) { printf("Ola!");}
\end{lstlisting}

A consistência de ``tudo ser objeto''\cite{abadi_theory_1996} parte dos príncipios de legibilidade e expressividade (acima por exemplo da eficiência em tempo de execução). É quase possível entender o código sem mesmo conhecer a linguagem. 
Veja o exemplo abaixo:

\begin{lstlisting}[language=java]
   exit unless "restaurante".include? "aura"
   ['toasty', 'cheese', 'wine'].each 
        { |food| print food.capitalize }
\end{lstlisting}

\subsection{Sobre a sintaxe}

Algumas itens sobre a sintaxe são apenas conveções. Embora, pode-se utilizar uma conveção arbitrária para nomes de classes e métodos, é importante manter
a consistência com os programas da linguagem.
 
\begin{itemize}
  \item  Espaços, tabulações e blocos de comentários serão ignorados pelo interpretador.
  \item  Ponto-e-vírgula e nova linha é considerado um novo comando. Porém, se for encontrado um operador, como `+', `-', ou o sinal de `\', indica que a 
próxima linha é continuação do comando atual.
  \item  Os identificadores são nomes de variáveis, constantes e métodos e é \em{case-sensitive}, ou seja, `DNS' e `Dns` são duas constantes diferentes.
  \item  Deve-se usar letras\_minúsculas para nomes de variáveis e métodos. `nome\_completo'
  \item  Deve-se usar LETRAS\_MAIÚSCULAS para nome de CONSTANTES. `MAX\_ATTENDEES = 100'
  \item  Deve-se usar \em{CamelCase} para nome de Classes. `NotificationMailer'
\end{itemize}

\subsection {Running Ruby}

Vamos criar uma arquivo Hello World! do Ruby.

\begin{lstlisting}[style=BashInputStyle]
$ echo 'puts "hello world"' > hello_word.rb
$ ruby hello_word.rb
\end{lstlisting}

A saída será: 

\begin{lstlisting}[style=BashOutputStyle]
hello world
\end{lstlisting}

Como ocorre com interpretadores como Perl, é possível passar o script por argumento na linha de comando:

\begin{lstlisting}[style=BashInputStyle]
$ ruby -e 'puts "hello world"'
\end{lstlisting}

A saída será a mesma:

\begin{lstlisting}[style=BashOutputStyle]
hello world
\end{lstlisting}

O ruby tem ainda um shell interativo (IRB) que pode ser usado para realizar testes:


\begin{lstlisting}[style=BashInputStyle]
$ irb
>> puts 'hello world'
hello world
=> nil
>>
\end{lstlisting}

\section{Estruturas básicas}

Nessa sessão veremos as estruturas básicas da linguagem: estruturas de controle e objetos básicos que são instanciados pelo próprio interpretador. Em Ruby, 
tudo que pode ser atribuído a uma variável é um objeto e todo objeto tem uma classe. Numa linguagem orientada a objetos, a forma básica de interagir com 
objetos é por meio de mensagens. Cada objeto ``entende'' um certo conjunto de mensagens definidos em métodos. A executação de um método se dá no envio da mensagem 
com o nome do método para o objeto. Em particular, toda classe ``entende" todos os métodos da classe Object. Veremos tudo isso em detalhes. Mas tomemos agora 
o método class e object. Esse método devolve a classe que o objeto pertence (ou qual classe foi utilizada para instanciar o objeto). Veja:
 

\begin{lstlisting}[language=ruby]
>> 1.class
=> Fixnum
>> "texto".class
=> String
>> :simbolo.class
=> Symbol
>> true.class
=> TrueClass
>> false.class
=> FalseClass
>> nil.class
=> NilClass
>> Object.class
=> Class
>> Class.class
=> Class
\end{lstlisting}


Já falei que em Ruby, TUDO é objeto?

\begin{lstlisting}[language=ruby]
>> 1.methods.count
=> 130
> 1.methods.sort
=> [:!, :!=, :!~, :%, :&, :*, :**, :+, :+@, :-, :-@, :/, :<, :<<, :<=, :<=>, :==, :===,
:=~, :>, :>=, :>>, :[], :^, :__id__, :__send__, :abs, :abs2, :angle, :arg, :between?,
:ceil, :chr, :class, :clone, :coerce, :conj, :conjugate, ...]
>> 'texto'.methods.count
=> 162
>> 'texto'.methods.sort
=> [:!, :!=, :!~, :%, :*, :+, :<, :<<, :<=, :<=>, :==, :===, :=~, :>, :>=, :[], :[]=,
:__id__, :__send__, :ascii_only?, :between?, :bytes, :bytesize, :byteslice, ...]
\end{lstlisting}

\subsection{Comentários}

Comentários são trechos em seu código que não serão processados pelo interpretador. Serve para documentar seu código.

\subsubsection{Uma linha}
\begin{lstlisting}[language=ruby]
 # Esta linha eh um comentario.
 1 + 1 # este texto a direita do sinal de # tambem eh um comentario.
\end{lstlisting}

\subsubsection{Múltiplas linhas}

\begin{lstlisting}[language=ruby]
=begin
O texto envolvido por =begin e =end é comentário.
Mas para isto funcionar, o =begin e =end devem estar
na exterma esquerda do seu código, ou seja, na coluna
0 (zero).
=end
\end{lstlisting}

\subsection{Números}

\subsubsection{Inteiros}

\begin{lstlisting}[language=ruby]
123                       # Inteiro (Fixnum)
-123                      # Inteiro negatico (Fixnum)
1_123                     # Inteiro (Fixnum)
123_456_789_123_456_789   # Inteiro (Bignum)
0xAB                      # Número Hexadecimal (170)
0377                      # Número Octal (255)
0b001001                  # Número binário (9)
\end{lstlisting}

\subsubsection{Pontos Flutuantes}

\begin{lstlisting}[language=ruby]
123.45                    # Número com ponto flutuante (Float)
1.2e-3                    # Número com ponto flutuante (0.0012)
\end{lstlisting}

\subsubsection{String 'single quotes'}

\begin{lstlisting}[language=ruby]
>> puts 'texto'
texto
>> puts 'texto'.length
5
>> puts 'texto'.upcase
TEXTO
>> puts 'tex'.+('to')
texto
>> puts 'tex' + 'to' # syntax sugar
texto
>> puts 'tex' << 'to'
texto
>> String.new << 'texto'
texto
>> 'tex%s' % 'to'
texto
\end{lstlisting}

Para usar os caracteres '\'' ou '\\', você pode usar sequência de \em{escape}  '\\\'' e '\\\\'.

\begin{lstlisting}[language=ruby]
>> puts 'texto \' \\'
texto ' \
\end{lstlisting}

\subsubsection{String 'double quotes'}

Existe uma diferença entre construir strings com aspas simples e aspas duplas. Strings montadas com aspas duplas, aceitam interpolação de conteúdo para construir a string final.

\begin{lstlisting}[language=ruby]
>> puts "o resultado de 1 + 1 é #{ 1 + 1 }."
o resultado de 1 + 1 é 2.
>> puts 'o resultado de 1 + 1 é #{ 1 + 1 }.'
o resultado de 1 + 1 é #{ 1 + 1 }.
\end{lstlisting}

O valor da expressão a ser interpolada, será o resultado do método 'to\_s' do objeto.

\subsubsection{Sequências de \em{escape}}

\begin{lstlisting}[language=ruby]
>> puts "      world\rhello"
hello world
>> puts "\thello \b\sworld"
    hello world
>> puts '\thello \b\sworld'
\thello \b\sworld
\end{lstlisting}

\begin{itemize}
  \item  '\textbackslash"' – double quote
  \item  '\textbackslash\textbackslash' – single backslash
  \item  '\textbackslash{}a' – bell/alert
  \item  '\textbackslash{}b' – backspace
  \item  '\textbackslash{}r' – carriage return
  \item  '\textbackslash{}n' – newline
  \item  '\textbackslash{}s' – space
  \item  '\textbackslash{}t' – tab
\end{itemize}


\subsubsection{String multiplas linhas}

\begin{lstlisting}[language=ruby]
>>> puts <DOC
 Esta é uma string em múltiplas linhas.
     * item
     * item
     * item
 DOC
\end{lstlisting}

Resultado:
\begin{lstlisting}[style=BashOutputStyle]
 Esta é uma string em múltiplas linhas.
     * item
     * item
     * item
\end{lstlisting}

Se quiser identar o finalizaror, para usar '<<-'.

\begin{lstlisting}[style=BashOutputStyle]
>>> puts <<-DOC
 Esta é uma string em múltiplas linhas.
     * item
     * item
     * item
     DOC
\end{lstlisting}

Resultado:
 \begin{lstlisting}[style=BashOutputStyle]
 Esta é uma string em múltiplas linhas.
     * item
     * item
     * item 
 \end{lstlisting}

\subsection{Símbolos}

Os símbolos são ideais para serem usados como chave em 'Hash'.

\begin{lstlisting}[language=ruby]
:x, :y, :chave
\end{lstlisting}

Símbolos são alocados uma única vez: ':a.object\_id' durante uma execução sempre retornara o mesmo valor. Isso não acontece com string.

O método 'equal?' só devolve 'true' se dois objetos são de fato o mesmo objeto (e instâncias da mesma classe com valores iguais).

\begin{lstlisting}[language=ruby]
1.equals?(1)             # => true
:key.equals?(:key)       # => true
"texto".equals?("texto") # => false
\end{lstlisting}

\begin{itemize}
  \item Variáveis 
\begin{lstlisting}[language=ruby]
x, y, taxa_do_lixo2
\end{lstlisting} 
   \item{Números}
\begin{lstlisting}[language=ruby]
1, -1.2, 6.03e-23    
\end{lstlisting}
	\item {String}
\begin{lstlisting}[language=ruby]
"alguma coisa assim"
%q(veremos outras formas de declarar strings)
\end{lstlisting}
 
\end{itemize}

\begin{itemize}
  \item Symbols
% * Symbols
\begin{lstlisting}[language=ruby]
:x, :y, :isso_parece_uma_string
\end{lstlisting}

  \item Constantes 
\begin{lstlisting}[language=ruby]  
EmpireStateBuilding, NEA, PI
\end{lstlisting}

  \item Objetos especiais 
\begin{lstlisting}[language=ruby]
true, false, nil
\end{lstlisting}
\end{itemize}

Símbolos são alocados uma única vez: :a.object\_id durante uma execução sempre
retornara o mesmo valor. Isso nao acontece com string. O método equal? so
devolve true se dois objetos são de fato o mesmo objeto (e instâncias da mesma
classe com valores iguais).

\subsection{Métodos (mensagens)}
\begin{lstlisting}[language=ruby]
i = 1        
texto = "um texto"; puts texto
a = b = c = 0
1 == 2           # sugar syntax!!!
# metodo de classe
1.methods  # lista todos os metodos daquele objeto
1.send(:even?) # outra forma de enviar mensagens
def fibo(n = 1)
    fibo(n-2) + fibo(n-1) if n >= 2
end
def self.log
  puts "metodo de classe"
end
\end{lstlisting}

Lembre-se ... voce pode redefinir um método
Quase tudo e objeto

\subsection{Estruturas de Controle - if}
 
       
\subsection {Exemplo Completo}
\begin{lstlisting}[language=ruby]
if count > 10
  puts "Try again"
elsif tries == 3
  puts "You lose"
  puts  Number:"
end
\end{lstlisting}

\subsection {Exemplo Simples}
\begin{lstlisting}[language=ruby]
if radiation > 3000
  puts "Danger"
end
\end{lstlisting}

\subsection {Modificador de Sentenca}
\begin{lstlisting}[language=ruby]
puts "Danger, Will Robinson" if radiation > 3000
\end{lstlisting}

\subsection{Estruturas de Controle - case} 
\begin{lstlisting}[language=ruby]
print "Enter your grade: "
grade = gets.chomp
case grade
when "A"
  puts 'Well done!'
when "B"
  puts 'Try harder!'
when "C", "D"
  puts 'You need help!!!'
  puts "You just making it up!"
 end
\end{lstlisting}


\subsection{Estruturas de Controle - while}
\begin{lstlisting}[language=ruby]
while weight < 100 and numPallets <= 30
  pallet = nextPallet()
  weight += pallet.weight
  numPallets += 1
end
\end{lstlisting}
 
\subsection {Modificador de Sentenca}
\begin{lstlisting}[language=ruby]
square = square*square  while square < 1000
\end{lstlisting}

\subsection{Estrutura de Controle -  for}
\begin{lstlisting}[language=ruby]
for i in 0..5
   puts "Value is #{i}"
end
\end{lstlisting}

\subsection{Estrutura de Controle -  until} 
\begin{lstlisting}[language=ruby]
until weight >= 100 ||numPallets > 30
  pallet = nextPallet()
  weight += pallet.weight
  numPallets += 1
end
\end{lstlisting}

\subsection {Modificador de Sentenca}
\begin{lstlisting}[language=ruby]
square = square*square  until square >= 1000
\end{lstlisting}

\subsection{Desafio - FizzBuzz}  
Escreva um programa que imprima o número de 1 a 100.
Mas, para múltiplos de três, imprima  ``Fizz'' no lugar do
número e para múltiplos de cinco imprima ``Buzz''. Para
números que são múltiplos de ambos três e cinco
imprima ``FizzBuzz''.
 
\url{http://www.rubyquiz.com/quiz126.html}

\subsection{Solução FizzBuzz}

\lstinputlisting[language=ruby]{../Exemplos/1-very_basic/fizzbuzz.rb}

\section{Containers}

\subsection{Array}
\begin{lstlisting}[language=ruby]
a = [ 3.14159, "pie", 99 ]
a.type   #        Array
a.length #        3
a[0]     #        3.14159
a << 1
a[3]     #        1
a[-2]    #        99
b = Array.new
b << a   #   [[3.14159, "pie", 99, 1]]
b[0..3] = a    #   [3.14159, "pie", 99, 1]
b[0, 2] = 1    #   [1, 1]
c = %w{a b c d e }  #  =>  ["a", "b", "c", "d"]
\end{lstlisting}


\subsection{Hash}
\begin{lstlisting}[language=ruby]
h = {'dog' => 'canine', 'cat' => 'feline', 'donkey' => 'asinine'}
h.length        #        3
h['dog']        #        "canine"
h['cow'] = 'bovine'
h[12]    = 'dodecine'
h['cat'] = 99
h        # => {"cow"=>"bovine", "cat"=>99, 12=>"dodecine",
"donkey"=>"asinine", "dog"=>"canine"}
  
a = [[1, 'a'],[2, 'b'],[3, 'c'], [4, 'd']]
b = Hash[a]
# => {1=>"a", 2=>"b", 3=>"c", 4=>"d"}
\end{lstlisting}


\subsection{Blocos e Iteradores}

Passando blocos
\begin{lstlisting}[language=ruby]
(1..12).each { |i| puts i}
[1, 2, 4].each do |i|
    puts i
end
\end{lstlisting}

Blocos de código
\begin{lstlisting}[language=ruby]
(1..20).each{|x| puts x}
\end{lstlisting}

Influência do Smalltalk:
\begin{lstlisting}[language=smalltalk]
   1 to: 20 do: [:x | x printN1]
\end{lstlisting}

\subsection{ Métodos de um Enumerable}
\begin{lstlisting}  
all?, any?, collect, detect, each_cons, each_slice, each_with_index, entries,
enum_cons, enum_slice, enum_with_index, find, find_all, grep, include?, inject,
map, max, member?, min, partition, reject, select, sort, sort_by, to_a,
to_set, zip
\end{lstlisting}
 
\subsection{Exemplos com Enumeraveis}
\begin{lstlisting}[language=ruby]
names = %w{ Frye Leela Zoidberg }
names.find {|name|  name.length>4}          # => "Leela"
names.find_all { |name| name.length > 4}
     #=> ["Leela", "Zoidberg"]
names.grep /oidberg/
# => ["Zoidberg"]
names.group_by {|name|  name.length}
   # =>  {4=>["Frye"], 5=>["Leela"], 8=>["Zoidberg"]}
\end{lstlisting}

\subsection{Mais exemplos com Enumeraveis}
\begin{lstlisting}[language=ruby]
names = %w{ Frye Leela Zoidberg }
names.map {|name| name.downcase}
# => ["frye", "leela", "zoidberg"]
names.reduce {|acc, name| name.length <= 5 ? acc + name : acc }
# => "FryeLeela"
names.join ", "
# => "Frye, Leela, Zoidberg"
\end{lstlisting}


\section{Blocos}

\subsection{yield}
\begin{lstlisting}[language=ruby]
def proxy_method
  puts "Calling command at: #{Time.new}"
  yield
proxy_method { puts "hello world proxified! "}
#ou com paremtros
def proxy_method
   yield(Time.new)
proxy_method {|time| puts "hello world proxified  at #{time}"}
\end{lstlisting}

\subsection{call}
\begin{lstlisting}[language=ruby]
def proxy_method(&method)
  # argumento com & precisa ser o ultimo da lista
  puts "Calling command at: #{Time.new}"
  method.call
proxy_method { puts "hello world proxified! "}
#ou com paremtros
def proxy_method (&method)
   method.call(Time.new)
proxy_method {|time| puts "hello world proxified  at #{time}"}
\end{lstlisting}

\subsection{Proc x Lambda}
\begin{lstlisting}[language=ruby]
fx = Proc.new {|x| x**2}
fxy = proc {|x,y| x+y}
# calling
fx.call(2) # => 4
fxy[2,3,4] #=> 5
fx = lambda {|x| x**2}
fxy = lambda {|x,y| x+y}
# calling
fx.call(2) # => 4
fxy.call(2,3,4) #=> exception na cara!
Proc.new e proc sao equivalentes
\end{lstlisting}


\subsection{Lambda ``Calculus''}

\begin{lstlisting}[language=ruby, caption="Derivada em Ruby"]
def d(f)
   lambda {|a|
     h = 0.0000000001 # um valor pequeno para h
     h = h * a       if a < 1 && 0 < a
     (f[a+h]-f[a])/h
   }
f = lambda {|x| x**2}
puts d(f)[4]
\end{lstlisting}

\section{Objetos em Ruby}
\begin{lstlisting}[language=ruby]
class BookInStock
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
 
  def to_s
    "ISBN:#{@isbn}, price: #{@price}"
  end
end
stock = BookInStock.new
# ou
stock = BookInStock.new (1234, 10.39)
#invocando metodo
puts stock.to_s
\end{lstlisting}


\subsection{Variaveis e Escopo}

\begin{tabular}{ l | c | r }
Variáveis Locais & \verb|x name thx1138 _x _26| \\
Variáveis de Instancia & \verb|@name @X  @_ @plan9| \\
Variáveis de Classe & \verb|@@total @@N @@x_pos| \\
Variáveis Globais & \verb|$debug $CUSTOM $_ $plan9| \\
Nomes de Classe & \verb|String BigDecimal| \\
Constants & \verb|FEET_PER_MILE DEBUG|
\end{tabular}

\subsection{Atributos de instância - forma tradicional}
\begin{lstlisting}[language=ruby]
class BookInStock  
  def isbn
    @isbn
  end
 
  def isbn=(value)
    @isbn = value
  end
 
  def price
    @price
  end
\end{lstlisting}

\subsection{Atributos de instância - forma declarativa}
\begin{lstlisting}[language=ruby]
class BookInStock  
  attr_accessor :isbn
  attr_reader :price
 end
\end{lstlisting}

\subsection{Herança}
\subsubsection{Exemplo de Heranca}
\begin{lstlisting}[language=ruby]
class SpecialStock < BookInStock
\end{lstlisting}

\subsection{Herança - Singleton Pattern}

\subsubsection{forma tradicional}
\begin{lstlisting}[language=ruby]
class Logger
  private_class_method :new
  @@logger = nil
  def Logger.create
    @@logger = new unless @@logger
    @@logger
  end
end
\end{lstlisting}

\subsubsection{módulo Singleton}
\begin{lstlisting}[language=ruby]
require 'singleton'
class Logger
  include Singleton
  
  def initialize
    @log = File.open("log.txt", "a")
  end
  def log(msg)
    @log.puts(msg)
  end
Logger.instance.log('message 2')
\end{lstlisting}

\begin{lstlisting}[language=ruby]
stock =  BookInStock.new
class << stock
   def alter_price
         price * 1.4
   end
\end{lstlisting}

\subsection{Criando um Enumerable}
  *  Basta implementar o metodo each. 
\begin{lstlisting}[language=ruby]
class Node
  include Enumerable 
  attr_accessor :next, :previous, :v
 def initialize(v = {})
    @v = v
  end
 def to_s
    v.to_s
  end
\end{lstlisting}

\begin{lstlisting}[language=ruby]
linked_list.rb (continuacao)
 def <<(node)
    node.next = self.next
    node.previous = self
    self.next.previous = node unless self.next.nil?
    self.next = node
  end
 def remove
    node = self.previous
    node.next = self.next
    self.next.previous = node
    self
 end
\end{lstlisting}

\begin{lstlisting}[language=ruby]
  def each
    node = self.next
    until node == self || node.nil?
      yield node
      node = node.next
    end
  end

\end{lstlisting}



\section{Mais sobre métodos}

\subsection{Lista de parâmetros}

\begin{lstlisting}[language=ruby]
def my_new_method               # No arguments
  # Code for the method would go here
end

def my_other_new_method(arg1, arg2, arg3)  # 3 arguments
  # Code for the method would go here
end

def cool_dude(arg1="Miles", arg2="Coltrane", arg3="Roach")  # defaults
  "#{arg1}, #{arg2}, #{arg3}."
end
\end{lstlisting}

\subsection{Truques com parâmetros}

Aridade não definida

\begin{lstlisting}[language=ruby]
def varargs(arg1, *rest)
  "Got #{arg1} and #{rest.join(', ')}"

varargs("one")  # "Got one and "
varargs("one", "two") # "Got one and two"
varargs "one", "two", "three" # "Got one and two, three"

def varargs(arg1, hash)
 puts "#{arg1} - #{hash}"
end

varargs (1, :a => 1)
end
\end{lstlisting}

\subsection{Array para argumentos}

Expandindo array para parâmetros

\begin{lstlisting}[language=ruby]
def five(a, b, c, d, e)
  "I was passed #{a} #{b} #{c} #{d} #{e}"
end

five(1, 2, 3, 4, 5 )         #  "I was passed 1 2 3 4 5"
five(1, 2, 3, *['a', 'b'])  # "I was passed 1 2 3 a b"
five(*(10..14).to_a)         #  "I was passed 10 11 12 13 14"
\end{lstlisting}

\subsection{Proc para bloco}

Convertendo proc para bloco

\begin{lstlisting}[language=ruby]
print "(t)imes or (p)lus: "
times = gets.chomp
print "number: "
number = gets.to_i

if times =~ /^t/
  calc = proc { |n| n*number }
else
  calc = proc { |n| n+number }
end

puts((1..10).collect(&calc).join(", "))
\end{lstlisting}

\section{Exceptions, Catch and Throw}

\begin{lstlisting}[language=ruby]
opFile = File.open(opName, "w")

while data = socket.read(512)
  opFile.write(data)
end
\end{lstlisting}

\subsection{Exceptions}

\begin{lstlisting}[language=ruby]
opFile = File.open(opName, "w")
begin
  # Exceptions raised by this code will
  # be caught by the following rescue clause
  while data = socket.read(512)
    opFile.write(data)
  end

rescue SystemCallError
  $stderr.print "IO failed: " + $!
  opFile.close
  File.delete(opName)
  raise
end
\end{lstlisting}

\subsection{Catching exception}

Nomeando a exceção

\begin{lstlisting}[language=ruby]

begin
  eval string
rescue SyntaxError, NameError => boom
  # OLHA! sem usar o $!
  print "String doesn't compile: " + boom
rescue StandardError => bang
  print "Error running script: " + bang
end
\end{lstlisting}

\subsection{Ensure}

Garante que um bloco é chamado

\begin{lstlisting}[language=ruby]

f = File.open("testfile")
begin
  # .. process
rescue
  # .. handle error
ensure
  f.close unless f.nil?
end
\end{lstlisting}

\subsection{Rescuing a Method}

Begin Rescue

\begin{lstlisting}[language=ruby]

def some_method
  begin
    danger_danger
    true # good return
  rescue Error
    false # error return
  end
end
\end{lstlisting}

Better code

\begin{lstlisting}[language=ruby]

def some_method
  danger_danger
  true # good response
rescue Error
  false # error response
end
\end{lstlisting}

\subsection{Raise Exceptions}

Formas típicas de se lançar uma exceção

\begin{lstlisting}[language=ruby]

 raise # sem mensagem

 # adicionando uma string...
 raise "Missing name" if name.nil?

 if i >= myNames.size
   raise IndexError, "#{i} >= size (#{myNames.size})"
 end

 # passando o stackTrace via Kernel::caller
 raise ArgumentError, "Name too big", caller
\end{lstlisting}

\subsection{Especializando Exceções}

Declaração

\begin{lstlisting}[language=ruby]

class RetryException < RuntimeError
  attr :okToRetry

  def initialize(okToRetry)
    @okToRetry = okToRetry
  end
end
\end{lstlisting}

Como lançar

\begin{lstlisting}[language=ruby]

def readData(socket)
  data = socket.read(512)
  if data.nil?
    raise RetryException.new(true), "transient read error"
  end
  # .. normal processing
end
\end{lstlisting}

\subsection{Especializando Exceções II}

Tratanto a exceção

\begin{lstlisting}[language=ruby]

begin
  stuff = readData(socket)
  # .. process stuff
rescue RetryException => detail
  retry if detail.okToRetry
  raise
end
\end{lstlisting}

\subsection{Catch e Throw}

Desvio incondicional com labels

\begin{lstlisting}[language=ruby]

def promptAndGet(prompt)
  print prompt
  res = readline.chomp
  throw :quitRequested if res == "!"
  return res
end

catch :quitRequested do
  name = promptAndGet("Name: ")
  age  = promptAndGet("Age:  ")
  sex  = promptAndGet("Sex:  ")
  # ..
  # process information
end
\end{lstlisting}

\section{Módulos}
Uso

\begin{enumerate}
  \item Criar namespace (evitar conflito de nomes)
  \item Mixin (permitir herança de traços – como se fosse uma cópia do conteúdo do módulo no local incluído)
\end{enumerate}

\subsection{Declaração}

\begin{lstlisting}[language=ruby]

module Trig
  PI = 3.141592654
  def Trig.sin(x)
   # ..
  end
  def Trig.cos(x)
   # ..
  end
end
\end{lstlisting}

\subsubsection{Uso}

\begin{lstlisting}[language=ruby]

require "./trig"
puts Trig.sin(Trig::PI / 3.0)
\end{lstlisting}

\subsection{Mixins}

Applying mixin

\begin{lstlisting}[language=ruby]

class BigInteger < Number
  # Adiciona metodos de instancia de Stringify
  include Stringify

  # Adiciona metodos de classe de Math
  extend Math

  # Adiciona um constructor com um parametro
  def initialize(value)
    @value = value
  end
end
\end{lstlisting}

\subsection{Applying mixin}

\begin{lstlisting}[language=ruby]

bigint1 = BigInteger.new(10)

puts bigint1.intValue   # --> 10

bigint2 = BigInteger.add(-2, 4)
puts bigint2.intValue   # --> 2

puts bigint2.stringify   # --> 'Two'

bigint2.extend CurrencyFormatter
\end{lstlisting}

\section{Pacotes Básicos}

\subsection{BigDecimal}

\begin{lstlisting}[language=ruby]

require 'bigdecimal'

BigDecimal.new('1.23) # => #<BigDecimal:7ffe0b052bc8,'0.123E1',18(18)>
\end{lstlisting}

\subsection{OpenStruct}

\begin{lstlisting}[language=ruby]
require 'ostruct'
\end{lstlisting}

\subsection{Test}

\begin{lstlisting}[language=ruby]

require "test/unit"

class TesteFoo  < Test::Unit::TestCase

  def test_eFoo_foo
    assert_same(1, 0, "Que pena")
  end
end
\end{lstlisting}

\subsection{ERB}

\begin{itemize}
  \item Sistema de Template padrão do Ruby
  \item Uma classe como outra qualquer
  \item Via linha de comando é possível parsear um arquivo erb
\end{itemize}

\begin{lstlisting}[language=ruby]
require 'erb'

template = ERB.new('1 + 1 = <%= 1 + 1 %>')
template.result # => '1 + 1 = 2'
\end{lstlisting}

\subsection{Net::HTTP}

\begin{lstlisting}[language=ruby]
	require "net/http"
	require "uri"
	require 'methodize'
	
	def get_page (string)
	  uri = URI.parse(string)
	  response = Net::HTTP.get_response(uri)
	  response.body
	end
\end{lstlisting}

\subsection{JSON}

\begin{lstlisting}[language=ruby]
	require "net/http"
	require "uri"
	require 'json'
	require 'methodize'
	
	def get_page (string)
	  uri = URI.parse(string)
	  response = Net::HTTP.get_response(uri)
	  json = JSON.parse(response.body)
	  json.extend(Methodize)
	end
\end{lstlisting}

\subsection{YAML}

\subsubsection{Arquivo yaml}

\begin{verbatim}
	simple symbol: !ruby/symbol Simple 
	shortcut syntax: !ruby/sym Simple 
	symbols in seqs: 
	  - !ruby/symbol ValOne 
	  - !ruby/symbol ValTwo 
	  - !ruby/symbol ValThree 
	symbols in maps: 
	  - !ruby/symbol MapKey: !ruby/symbol MapValue 
\end{verbatim}

\subsubsection{Ruby code}

\begin{lstlisting}[language=ruby]
	require "yaml"
	
	config = YAML.load_file("config.yml") # From file
	p config
\end{lstlisting}

\subsubsection{Result}

\begin{verbatim}
{"simple symbol"=>:Simple, "shortcut syntax"=>:Simple, 
"symbols in seqs"=>[:ValOne, :ValTwo, :ValThree], 
"symbols in maps"=>[{:MapKey=>:MapValue}]}
\end{verbatim}


\bibliography{bibliografia}
\bibliographystyle{plain}

\end{document}
