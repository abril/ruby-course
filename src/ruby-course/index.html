<!DOCTYPE html>
<html>
  <head>
    <link href="css/reset.css" rel="stylesheet" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1024" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link rel="shortcut icon" href="css/favicon.png" />
    <link rel="apple-touch-icon" href="css/apple-touch-icon.png" />
    <!-- Code Prettifier: -->
<link href="css/highlight.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

    <link href="css/style.css" rel="stylesheet" />
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|PT+Sans:400,700,400italic,700italic|PT+Serif:400,700,400italic,700italic" rel="stylesheet" />
  </head>

  <body>
  <div class="fallback-message">
  <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
  <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
  </div>
    <div id="impress">
    <div class='step' >
    
<h1 class='capa'>Curso de Introdução a programação com Ruby</h1>

<p><a href="http://bit.ly/cursorubyabril">http://bit.ly/cursorubyabril</a> - <a href="https://github.com/abril/ruby-course">https://github.com/abril/ruby-course</a></p>
</div>
      <div class='step' >
    
<h1>Sumário</h1>

<ul>
<li>  Introdução: Ruby.new</li>
<li>  Estruturas Básicas</li>
<li>  Bloco de código</li>
<li>  Estruturas de Controle</li>
<li>  Containers e Iterators</li>
<li>  Classe, Objetos e Variáveis</li>
<li>  Mais sobre Métodos</li>
<li>  Tratamento de Exceções</li>
<li>  Módulos</li>
<li>  Pacotes básicos</li>
<li>  ERB (templates em ruby)</li>
<li>  Dojo</li>
</ul>

<p>* Não necessariamente nessa ordem.</p>
</div>
      <div class='step'  data-x="1000" data-scale="2">
    
<h1>Introdução:Ruby.new</h1>

<p>Ruby é uma linguagem de programação <strong>interpretada</strong>, de <strong>tipagem dinâmica e forte</strong>, com <strong>gerenciamento de memória automático</strong>, originalmente planejada e desenvolvida no Japão em 1995, por Yukihiro &quot;Matz&quot; Matsumoto, para ser usada como linguagem de script.</p>

<p>Matz queria uma linguagem de script que fosse mais poderosa do que Perl, e mais orientada a objetos do que Python. Ruby é primariamente, uma linguagem <strong>orientada a objetos</strong>, mas suporta outros paradigmas de programação, como <strong>funcional</strong>, <strong>imperativa</strong> e <strong>reflexiva</strong>.</p>

<p>Foi inspirada principalmente por Python, Perl, Smalltalk, Eiffel, Ada e Lisp, sendo muito similar em vários aspectos a Python.</p>

<p>fonte: <a href="http://bit.ly/wiki-ruby">Wikipedia - http://bit.ly/wiki-ruby</a></p>
</div>
      <div class='step' >
    
<h1>Introdução:Ruby.new</h1>

<h2>Instalação</h2>

<h3>Windows</h3>

<p>Baixar o executável de instalação em <a href="http://rubyinstaller.org/downloads/">http://rubyinstaller.org/downloads/</a></p>

<h3>Linux (Debian / Ubuntu)*</h3>
<pre><code class='prettyprint bash'>$ [sudo] apt-get install ruby1.9.1
</code></pre>
<h3>Mac (via Homebrew)*</h3>
<pre><code class='prettyprint bash'>$ brew install ruby
</code></pre>
<p>* Linux e Mac normalmente já vem com uma instalação de Ruby.</p>
</div>
      <div class='step' >
    
<h1>Introdução:Ruby.new</h1>

<p>Verificar a versão de ruby instalada, digite <code class='inline prettyprint'>ruby --version</code></p>
<pre><code class='prettyprint bash'>$ ruby --version
ruby 1.9.3p374 (2013-01-15 revision 38858) [x86_64-darwin10.8.0]
</code></pre>
<p>* <code class='inline prettyprint'>ruby -v</code> também imprime a versão do ruby, porém ativa o modo <em>verbose</em> e permite executar scripts.</p>
</div>
      <div class='step' >
    
<h1>Introdução:Ruby.new</h1>

<h2>Editores</h2>

<ul>
<li><a href="http://www.sublimetext.com/2">Sublime Text 2 (Windows, Linux e Mac)</a></li>
<li><a href="http://www.vim.org/">Vim</a></li>
<li><a href="http://www.gnu.org/software/emacs/">Emacs</a></li>
<li><a href="https://github.com/textmate/textmate/">TextMate 2</a></li>
<li><a href="https://netbeans.org/downloads/6.9.1/index.html">Netbeans 6.9.1</a></li>
<li><a href="http://www.aptana.com/">Aptana</a></li>
</ul>
</div>
      <div class='step' >
    
<h1>Introdução:Ruby.new</h1>

<p>Sobre a sintaxe:</p>

<ul>
<li>Espaços, tabulações e blocos de comentários serão ignorados pelo interpretador.</li>
<li>Ponto-e-vírgula e nova linha é considerado um novo comando. Porém, se for encontrado um operador, como <code class='inline prettyprint'>+</code>, <code class='inline prettyprint'>-</code>, ou o sinal de <code class='inline prettyprint'>\</code>, indica que a próxima linha é continuação do comando atual.</li>
<li>Os identificadores são nomes de variáveis, constantes e métodos e é <em>case-sensitive</em>, ou seja, <code class='inline prettyprint'>DNS</code> e <code class='inline prettyprint'>Dns</code> são duas constantes diferentes.</li>
<li>Deve-se usar letras_minúsculas para nomes de variáveis e métodos. <code class='inline prettyprint'>nome_completo</code></li>
<li>Deve-se usar LETRAS_MAIÚSCULAS para nome de CONSTANTES. <code class='inline prettyprint'>MAX_ATTENDEES = 100</code></li>
<li>Deve-se usar <em>CamelCase</em> para nome de Classes. <code class='inline prettyprint'>NotificationMailer</code></li>
</ul>
</div>
      <div class='step' >
    
<h1>Introdução:Ruby.new</h1>

<h2>Hello World!</h2>

<h3>via arquivo</h3>
<pre><code class='prettyprint bash'>$ echo 'puts "hello world"' > hello_word.rb
$ ruby hello_word.rb
hello world
</code></pre>
<h3><em>one-liner</em></h3>
<pre><code class='prettyprint bash'>$ ruby -e 'puts "hello world"'
hello world
</code></pre>
<h3><em>Interactive Ruby</em> (IRB)</h3>
<pre><code class='prettyprint bash'>$ irb
>> puts 'hello world'
hello world
=> nil
>>
</code></pre></div>
      <div class='step' >
    
<h1>Introdução: Ruby.new</h1>

<h3>Compare este laço:</h3>
<pre><code class='prettyprint ruby'>5.times { print 'Ola!' }
</code></pre>
<h3>com este em PHP:</h3>
<pre><code class='prettyprint php'>for (int i=0; i <10; i++) { printf("Ola!");}
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas básicas</h1>

<p>Exceto para bloco de código, que será visto mais a frente, tudo em Ruby é um objeto.</p>
<pre><code class='prettyprint javascript'>>> 1.class
=> Fixnum
>> "texto".class
=> String
>> :simbolo.class
=> Symbol
>> true.class
=> TrueClass
>> false.class
=> FalseClass
>> nil.class
=> NilClass
>> Object.class
=> Class
>> Class.class
=> Class
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas básicas</h1>

<p>Já falei que em Ruby, TUDO é objeto?</p>
<pre><code class='prettyprint ruby'>>> 1.methods.count
=> 130
> 1.methods.sort
=> [:!, :!=, :!~, :%, :&, :*, :**, :+, :+@, :-, :-@, :/, :<, :<<, :<=, :<=>, :==, :===,
:=~, :>, :>=, :>>, :[], :^, :__id__, :__send__, :abs, :abs2, :angle, :arg, :between?,
:ceil, :chr, :class, :clone, :coerce, :conj, :conjugate, ...]
>> 'texto'.methods.count
=> 162
>> 'texto'.methods.sort
=> [:!, :!=, :!~, :%, :*, :+, :<, :<<, :<=, :<=>, :==, :===, :=~, :>, :>=, :[], :[]=,
:__id__, :__send__, :ascii_only?, :between?, :bytes, :bytesize, :byteslice, ...]
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas básicas</h1>

<h2>Comentários</h2>

<p>Comentários são trechos em seu código que não serão processados pelo interpretador. Serve para documentar seu código.</p>

<h3>Uma linha</h3>
<pre><code class='prettyprint ruby'># Esta linha é um comentário.
1 + 1 # este texto a direita do sinal de # também é um comentário.
</code></pre>
<h3>Múltiplas linhas</h3>
<pre><code class='prettyprint ruby'>=begin
O texto envolvido por =begin e =end é comentário.
Mas para isto funcionar, o =begin e =end devem estar
na exterma esquerda do seu código, ou seja, na coluna
0 (zero).
=end
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas básicas</h1>

<h2>Números</h2>

<h3>Inteiros</h3>
<pre><code class='prettyprint ruby'>123                       # Inteiro (Fixnum)
-123                      # Inteiro negatico (Fixnum)
1_123                     # Inteiro (Fixnum)
123_456_789_123_456_789   # Inteiro (Bignum)
0xAB                      # Número Hexadecimal (170)
0377                      # Número Octal (255)
0b001001                  # Número binário (9)
</code></pre>
<h3>Flutuantes</h3>
<pre><code class='prettyprint ruby'>123.45                    # Número com ponto flutuante (Float)
1.2e-3                    # Número com ponto flutuante (0.0012)
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas básicas</h1>

<h2>String <code class='inline prettyprint'>'single quotes'</code></h2>
<pre><code class='prettyprint ruby'>>> puts 'texto'
texto
>> puts 'texto'.length
5
>> puts 'texto'.upcase
TEXTO
>> puts 'tex'.+('to')
texto
>> puts 'tex' + 'to' # syntax sugar
texto
>> puts 'tex' << 'to'
texto
>> String.new << 'texto'
texto
>> 'tex%s' % 'to'
texto
</code></pre>
<p>Para usar os caracteres <code class='inline prettyprint'>'</code> ou <code class='inline prettyprint'>\</code>, você pode usar sequência de <em>escape</em> <code class='inline prettyprint'>\'</code> e <code class='inline prettyprint'>\\</code>.</p>
<pre><code class='prettyprint ruby'>>> puts 'texto \' \\'
texto ' \
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas básicas</h1>

<h2>String <code class='inline prettyprint'>"double quotes"</code></h2>

<p>Existe uma diferença entre construir strings com aspas simples e aspas duplas. Strings montadas com aspas duplas, aceitam interpolação de conteúdo para construir a string final.</p>
<pre><code class='prettyprint ruby'>>> puts "o resultado de 1 + 1 é #{ 1 + 1 }."
o resultado de 1 + 1 é 2.
>> puts 'o resultado de 1 + 1 é #{ 1 + 1 }.'
o resultado de 1 + 1 é #{ 1 + 1 }.
</code></pre>
<p>O valor da expressão a ser interpolada, será o resultado do método <code class='inline prettyprint'>to_s</code> do objeto.</p>

<p>Sequências de <em>escape</em></p>

<div style='float:right;width:60%'>
<pre class='prettyprint'><code class='language-ruby'>>> puts "hello\nworld"
hello
world
>> puts "      world\rhello"
hello world
>> puts "\thello \b\sworld"
    hello world
>> puts '\thello \b\sworld'
\thello \b\sworld
</code></pre>
</div>

<ul>
<li><code class='inline prettyprint'>\"</code> – double quote</li>
<li><code class='inline prettyprint'>\\</code> – single backslash</li>
<li><code class='inline prettyprint'>\a</code> – bell/alert</li>
<li><code class='inline prettyprint'>\b</code> – backspace</li>
<li><code class='inline prettyprint'>\r</code> – carriage return</li>
<li><code class='inline prettyprint'>\n</code> – newline</li>
<li><code class='inline prettyprint'>\s</code> – space</li>
<li><code class='inline prettyprint'>\t</code> – tab</li>
</ul>
</div>
      <div class='step' >
    
<h1>Estruturas básicas</h1>

<h2>String multiplas linhas</h2>

<pre class='prettyprint'><code class='language-ruby'>>> puts <&lt;DOC
Esta é uma string em múltiplas linhas.
    * item
    * item
    * item
DOC
# Resultado
Esta é uma string em múltiplas linhas.
    * item
    * item
    * item
</code></pre>

<p>Se quiser identar o finalizaror, para usar <code class='inline prettyprint'><<-</code>.</p>

<pre class='prettyprint'><code class='language-ruby'>>> puts <<-DOC
Esta é uma string em múltiplas linhas.
    * item
    * item
    * item
    DOC
# Resultado
Esta é uma string em múltiplas linhas.
    * item
    * item
    * item
</code></pre>

<p>* aceita interpolação.</p>
</div>
      <div class='step' >
    
<h1>Estruturas básicas</h1>

<h2>Símbolos</h2>

<p>Os símbolos são ideais para serem usados como chave em <code class='inline prettyprint'>Hash</code>.</p>
<pre><code class='prettyprint ruby'>:x, :y, :chave
</code></pre>
<p>Símbolos são alocados uma única vez: <code class='inline prettyprint'>:a.object_id</code> durante uma execução sempre retornara o mesmo valor. Isso não acontece com string.</p>

<p>O método <code class='inline prettyprint'>equal?</code> só devolve <code class='inline prettyprint'>true</code> se dois objetos são de fato o mesmo objeto (e instâncias da mesma classe com valores iguais).</p>
<pre><code class='prettyprint ruby'>1.equals?(1)             # => true
:key.equals?(:key)       # => true
"texto".equals?("texto") # => false
</code></pre></div>
      <div class='step' >
    
<h1>Containers</h1>

<h2>Array (Lista)</h2>
<pre><code class='prettyprint ruby'>a = [ 3.14159, "pie", 99 ]
a.type   #        Array
a.length #        3
a[0]     #        3.14159
a << 1
a[3]     #        1
a[-2]    #        99
b = Array.new
b << a   #   [[3.14159, "pie", 99, 1]]
b[0..3] = a    #   [3.14159, "pie", 99, 1]
b[0, 2] = 1    #   [1, 1]
c = %w{a b c d e }  #  =>  ["a", "b", "c", "d"]
</code></pre>
<p>* Os valores em um <code class='inline prettyprint'>Array</code> é apenas uma referência para a instância do objeto em memória</p>
</div>
      <div class='step' >
    
<h1>Containers</h1>

<h2>Hash (Dicionário) - é uma lista não ordenada, mas com chave e valor</h2>
<pre><code class='prettyprint ruby'>h = {:dog => 'canine', :cat => 'feline', :donkey => 'asinine'}
h.length            #        3
h[:dog]             #        "canine"
h[:cow] = 'bovine'
h[12]   = 'dodecine'
h[:cat] = 99
h
=> {:cow=>"bovine", :cat=>99, 12=>"dodecine", :donkey=>"asinine", :dog=>"canine"}

a = [[1, 'a'],[2, 'b'],[3, 'c'], [4, 'd']]
b = Hash[a]
# => {1=>"a", 2=>"b", 3=>"c", 4=>"d"}
</code></pre>
<h2>Ranger (Intervalos)</h2>
<pre><code class='prettyprint ruby'>puts (4..9).include? 7  # => true
</code></pre></div>
      <div class='step' >
    
<h1>Variáveis e Escopo</h1>
<pre><code class='prettyprint ruby'>$variavel_global

@@variavel_de_classe

@variavel_de_instancia

[Classe::]CONSTANTE

variavel_local
</code></pre></div>
      <div class='step' >
    
<h1>Pseudo variáveis</h1>
<pre><code class='prettyprint ruby'>self     # é o contexto atual que será usado para enviar mensagem
true
false
nil
__FILE__ # nome do arquivo de script atual em execução
__LINE__ # número da linha atual do script em execução
</code></pre></div>
      <div class='step' >
    
<h1>Variáveis pré definidas</h1>
<pre><code class='prettyprint ruby'>$0        # nome do processo atual em execução
$$        # PID do processo atual no SO
$stdin    # entrada padrão de dados (STDIN)
$stdout   # saída padrão de dados (STDOUT)
$VERBOSE  # retorna true se script carregado com -v, --verbose ou -w
$[numero] # retorna o grupo referente a ùltima expressão regular executada
</code></pre>
<p>* Esta é uma lista reduzida.</p>
</div>
      <div class='step' >
    
<h1>Constantes pré definitas</h1>
<pre><code class='prettyprint ruby'>TRUE    # == true
FALSE   # == false
NIL     # == nil
ARGV    # Array com a lista de parametros passados no momento de execução do script.
ENV     # Um hash com todas as variáveis de ambiente do seu sistema.
</code></pre>
<p>* Esta é uma lista reduzida.</p>
</div>
      <div class='step' >
    
<h1>Expressão regular</h1>

<p>Expressão regular pode ser declarada entre <code class='inline prettyprint'>/</code> ou usando o operador <code class='inline prettyprint'>%r</code></p>
<pre><code class='prettyprint ruby'>/pattern/
%r[pattern]
</code></pre>
<p>Após a declaração do padrão, pode-se aplicar modificadores, após <code class='inline prettyprint'>/</code>, e são eles: <code class='inline prettyprint'>i</code> ignorar case, <code class='inline prettyprint'>o</code> permitir interpolação, <code class='inline prettyprint'>x</code> ignorar espaços e permitir comentários e <code class='inline prettyprint'>m</code> fazer busca em múltiplas linhas, reconhecendo o caracter de nova linha <code class='inline prettyprint'>\n</code></p>
<pre><code class='prettyprint ruby'>/pattern/i
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas de Controle</h1>

<h2>Condicional <code class='inline prettyprint'>if</code></h2>

<h3>Exemplo Completo</h3>
<pre><code class='prettyprint ruby'>count = gets.chomp.to_i

if count > 10
  puts "Try again"
elsif tries == 3
  puts "You lose"
else
  puts  "Number: #{count}"
end
</code></pre>
<h3>Exemplo Simples</h3>
<pre><code class='prettyprint ruby'>if radiation > 3000
  puts "Danger"
end
</code></pre>
<h3>Modificador de Sentenca</h3>
<pre><code class='prettyprint ruby'>puts "Danger, Will Robinson" if radiation > 3000
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas de Controle</h1>

<h2>Condicional <code class='inline prettyprint'>unless</code></h2>

<p>É o inverso do condicional <code class='inline prettyprint'>if</code>. Então, ao invés de usar:</p>
<pre><code class='prettyprint ruby'>if not 'abc'.include? grau
  puts 'você está de recuperação'
end
</code></pre>
<p>use...</p>
<pre><code class='prettyprint ruby'>unless 'abc'.include? grau
  puts 'você está de recuperação'
end
</code></pre>
<h3>Modificador de Sentenca</h3>
<pre><code class='prettyprint ruby'>puts 'você está de recuperação' unless 'abc'.include? grau
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas de Controle</h1>

<h3>Condicional <code class='inline prettyprint'>case</code></h3>
<pre><code class='prettyprint ruby'>print "Enter your grade: "
grade = gets.chomp
case grade
  when "A"
    puts 'Well done!'
  when "B"
    puts 'Try harder!'
  when "C", "D"
    puts 'You need help!!!'
    puts "You just making it up!"
  else
    puts "You just making it up!"
end
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas de Controle</h1>

<p>Nas estruturas de controle que serão vistas a seguir, em todas existe a possibilidade de quebrar o fluxo do bloco a ser executado. <code class='inline prettyprint'>break</code> interrompe o fluxo para fora do bloco, <code class='inline prettyprint'>next</code> pula para a próxima iteração e <code class='inline prettyprint'>redo</code> para reiniciar o loop.</p>

<h2>Loop <code class='inline prettyprint'>while</code></h2>
<pre><code class='prettyprint ruby'>weight = num_pallets = 0
while weight < 100 and num_pallets <= 30
  weight += rand(10)

  # Sai do loop se o peso for um múltiplo de 5
  break if (weight % 5 == 0)

  num_pallets += 1
end

puts weight, num_pallets
</code></pre>
<h4>Modificador de Sentenca</h4>
<pre><code class='prettyprint ruby'>square = square*square  while square < 1000
</code></pre></div>
      <div class='step' >
    
<h1>Estrutura de Controle</h1>

<h2>Loop <code class='inline prettyprint'>for</code></h2>
<pre><code class='prettyprint ruby'>for i in 0..5
  puts "Value is #{i}"
end
</code></pre>
<p>Apesar de existir o loop <code class='inline prettyprint'>for</code>, em Ruby é comum fazer iteração através do método <code class='inline prettyprint'>each</code> do objeto. Veremos mais a frente.</p>
<pre><code class='prettyprint ruby'>(0..5).each do |i|
  puts "Value is #{i}"
end
</code></pre></div>
      <div class='step' >
    
<h1>Estrutura de Controle</h1>

<h2>Loop <code class='inline prettyprint'>until</code></h2>
<pre><code class='prettyprint ruby'>until weight >= 100 ||numPallets > 30
  pallet = nextPallet()
  weight += pallet.weight
  numPallets += 1
end
</code></pre>
<h3>Modificador de Sentenca</h3>
<pre><code class='prettyprint ruby'>square = square*square  until square >= 1000
</code></pre></div>
      <div class='step' >
    
<h1>Bloco de código</h1>

<p>O bloco de código é um trecho de código que será passado para um método, a ser usado internamente pela mesmo.</p>

<h2>Para blocos de uma única linha, deve-se usar as <code class='inline prettyprint'>{chaves}</code></h2>
<pre><code class='prettyprint ruby'>metodo { puts "estou dentro do metodo" }
</code></pre>
<h2>Para blocos com mais de uma linha, usa-se o com os delimitadores <code class='inline prettyprint'>do</code> e <code class='inline prettyprint'>end</code></h2>
<pre><code class='prettyprint ruby'>metodo do
  puts "estou dentro do metodo"
end
</code></pre>
<p>* Existe a possibilidade de receber parâmetros para seu bloco, no caso, basta envolver entre <code class='inline prettyprint'>|</code></p>
<pre><code class='prettyprint ruby'>metodo {|valor| puts "#{valor} dentro do metodo" }
</code></pre></div>
      <div class='step' >
    
<h1>Métodos de um Enumerable</h1>
<pre><code class='prettyprint ruby'>all?, any?, collect, detect, each_cons, each_slice, each_with_index, entries,
enum_cons, enum_slice, enum_with_index, find, find_all, grep, include?, inject,
map, max, member?, min, partition, reject, select, sort, sort_by, to_a,
to_set, zip
</code></pre></div>
      <div class='step' >
    
<h1>Exemplos com Enumeraveis</h1>
<pre><code class='prettyprint ruby'>names = %w{ Frye Leela Zoidberg }
names.find {|name|  name.length > 4 }     # => "Leela"
names.find_all { |name| name.length > 4}  # => ["Leela", "Zoidberg"]
names.grep /oidberg/                      # => ["Zoidberg"]
names.group_by {|name|  name.length}      # =>  {4=>["Frye"], 5=>["Leela"], 8=>["Zoidberg"]}
</code></pre></div>
      <div class='step' >
    
<h1>Mais exemplos com Enumeraveis</h1>
<pre><code class='prettyprint ruby'>names = %w{ Frye Leela Zoidberg }
names.map {|name| name.downcase} # => ["frye", "leela", "zoidberg"]
names.reduce {|acc, name| name.length <= 5 ? acc + name : acc } # => "FryeLeela"
names.join ", " # => "Frye, Leela, Zoidberg"
</code></pre></div>
      <div class='step' >
    
<h1>Invocando blocos</h1>
<pre><code class='prettyprint ruby'>def proxy_method
  puts "Calling command at: #{Time.new}"
  yield
end

proxy_method { puts "hello world proxified! "}

def proxy_method
   yield(Time.new)
end

proxy_method {|time| puts "hello world proxified  at #{time}"}
</code></pre></div>
      <div class='step' >
    
<h1>Invocando blocos II</h1>
<pre><code class='prettyprint ruby'>def proxy_method(&method)
  # argumento com & precisa ser o ultimo da lista
  puts "Calling command at: #{Time.new}"
  method.call
end

proxy_method { puts "hello world proxified! "}

# ou com paremtros
def proxy_method (&method)
   method.call(Time.new)
end
proxy_method {|time| puts "hello world proxified  at #{time}"}
</code></pre></div>
      <div class='step' >
    
<h1>Proc x Lambda</h1>
<pre><code class='prettyprint ruby'>fx = Proc.new {|x| x**2}
fxy = proc {|x,y| x+y}
# calling
fx.call(2) # => 4
fxy[2,3,4] #=> 5
fx = lambda {|x| x**2}
fxy = lambda {|x,y| x+y}
# calling
fx.call(2) # => 4
fxy.call(2,3,4) #=> exception na cara!
Proc.new e proc sao equivalentes
</code></pre></div>
      <div class='step' >
    
<h1>Lambda “Calculus”</h1>
<pre><code class='prettyprint ruby'>def d(f)
  lambda do |a|
    h = 0.0000000001 # um valor pequeno para h
    h = h * a  if a < 1 && 0 < a
    (f[a+h]-f[a])/h
  end
end
f = lambda {|x| x**2}
puts d(f)[4]
</code></pre></div>
      <div class='step' >
    
<h1>Objetos em Ruby</h1>
<pre><code class='prettyprint ruby'>class BookInStock
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end

  def to_s
    "ISBN:#{@isbn}, price: #{@price}"
  end
end

stock = BookInStock.new(1234, 10.39)
puts stock.to_s
</code></pre></div>
      <div class='step' >
    
<h1>Atributos de instância - forma tradicional</h1>
<pre><code class='prettyprint ruby'>class BookInStock
  def isbn
    @isbn
  end

  def isbn=(value)
    @isbn = value
  end

  def price
    @price
  end
end
</code></pre></div>
      <div class='step' >
    
<h1>Atributos de instância - forma declarativa</h1>
<pre><code class='prettyprint ruby'>class BookInStock
  attr_accessor :isbn
  attr_reader :price
end
</code></pre></div>
      <div class='step' >
    
<h1>Herança</h1>

<h2>Exemplo de Heranca</h2>
<pre><code class='prettyprint ruby'>class SpecialStock < BookInStock
end
</code></pre></div>
      <div class='step' >
    
<h1>Herança - Singleton Pattern</h1>

<h2>forma tradicional</h2>
<pre><code class='prettyprint ruby'>class Logger
  private_class_method :new
  @@logger = nil
  def Logger.create
    @@logger = new unless @@logger
    @@logger
  end
end
</code></pre></div>
      <div class='step' >
    
<h2>módulo Singleton</h2>
<pre><code class='prettyprint ruby'>require 'singleton'
class Logger
  include Singleton

  def initialize
    @log = File.open("log.txt", "a")
  end
  def log(msg)
    @log.puts(msg)
  end
end

Logger.instance.log('message 2')
</code></pre></div>
      <div class='step' >
    
<h1>Eigenclass</h1>
<pre><code class='prettyprint ruby'>stock =  BookInStock.new
class << stock
  def alter_price
    price * 1.4
  end
end
</code></pre></div>
      <div class='step' >
    
<h1>Criando um Enumerable (I)</h1>

<p>* Basta implementar o metodo <code class='inline prettyprint'>each</code>.</p>
<pre><code class='prettyprint ruby'>class Node
  include Enumerable
  attr_accessor :next, :previous, :v

  def initialize(v = {})
    @v = v
  end

  def to_s
    v.to_s
  end
end
</code></pre></div>
      <div class='step' >
    
<h1>Criando um Enumerable (II)</h1>

<p>class Node
  # continuação
  def &lt;&lt;(node)
    node.next = self.next
    node.previous = self
    self.next.previous = node unless self.next.nil?
    self.next = node
  end</p>

<p>def remove
    node = self.previous
    node.next = self.next
    self.next.previous = node
    self
  end
end
```</p>
</div>
      <div class='step' >
    
<h1>Criando um Enumerable (III)</h1>
<pre><code class='prettyprint ruby'>  class Node
    # continuação
    def each
      node = self.next
      until node == self || node.nil?
      yield node
      node = node.next
    end
  end
end
</code></pre></div>
      <div class='step' >
    
<h1>Mais sobre metodos</h1>

<p>Lista de parâmetros:</p>
<pre><code class='prettyprint ruby'>def my_new_method               # No arguments
  # Code for the method would go here
end

def my_other_new_method(arg1, arg2, arg3)  # 3 arguments
  # Code for the method would go here
end

def cool_dude(arg1="Miles", arg2="Coltrane", arg3="Roach")  # defaults
  "#{arg1}, #{arg2}, #{arg3}."
end
</code></pre></div>
      <div class='step' >
    
<h1>Truques com parâmetros</h1>

<p>Aridade não definida</p>
<pre><code class='prettyprint ruby'>def varargs(arg1, *rest)
  "Got #{arg1} and #{rest.join(', ')}"
end

varargs("one")  # "Got one and "
varargs("one", "two") # "Got one and two"
varargs "one", "two", "three" # "Got one and two, three”

def varargs(arg1, hash)
 puts “#{arg1} - #{hash}”
end

varargs (1, :a => 1)
</code></pre></div>
      <div class='step' >
    
<h1>Array para argumentos</h1>

<p>Expandindo array para parâmetros</p>
<pre><code class='prettyprint ruby'>def five(a, b, c, d, e)
  "I was passed #{a} #{b} #{c} #{d} #{e}"
end

five(1, 2, 3, 4, 5 )         #  "I was passed 1 2 3 4 5"
five(1, 2, 3, *['a', 'b'])  # "I was passed 1 2 3 a b"
five(*(10..14).to_a)         #  "I was passed 10 11 12 13 14"
</code></pre></div>
      <div class='step' >
    
<h1>Proc para bloco</h1>

<p>Convertendo proc para bloco</p>
<pre><code class='prettyprint ruby'>print "(t)imes or (p)lus: "
times = gets.chomp
print "number: "
number = gets.to_i

if times =~ /^t/
  calc = proc { |n| n*number }
else
  calc = proc { |n| n+number }
end

puts((1..10).collect(&calc).join(", "))
</code></pre></div>
      <div class='step' >
    
<h1>Exceptions, Catch and Throw</h1>
<pre><code class='prettyprint ruby'>opFile = File.open(opName, "w")

while data = socket.read(512)
  opFile.write(data)
end
</code></pre></div>
      <div class='step' >
    
<h1>Exceptions</h1>
<pre><code class='prettyprint ruby'>opFile = File.open(opName, "w")
begin
  # Exceptions raised by this code will
  # be caught by the following rescue clause
  while data = socket.read(512)
    opFile.write(data)
  end

rescue SystemCallError
  $stderr.print "IO failed: " + $!
  opFile.close
  File.delete(opName)
  raise
end
```ruby

---
# Catching exception

Nomeando a exceção

```ruby
begin
  eval string
rescue SyntaxError, NameError => boom
  # OLHA! sem usar o $!
  print "String doesn't compile: " + boom
rescue StandardError => bang
  print "Error running script: " + bang
end
</code></pre></div>
      <div class='step' >
    
<h1>Ensure</h1>

<p>Garante que um bloco é chamado</p>
<pre><code class='prettyprint ruby'>f = File.open("testfile")
begin
  # .. process
rescue
  # .. handle error
ensure
  f.close unless f.nil?
end
</code></pre></div>
      <div class='step' >
    
<h1>Rescuing a Method</h1>

<p>Begin Rescue</p>
<pre><code class='prettyprint ruby'>def some_method
  begin
    danger_danger
    true # good return
  rescue Error
    false # error return
  end
end
</code></pre>
<p>Better code</p>
<pre><code class='prettyprint ruby'>def some_method
  danger_danger
  true # good response
rescue Error
  false # error response
end
</code></pre></div>
      <div class='step' >
    
<h1>Raise Exceptions</h1>

<p>Formas típicas de se lançar uma exceção</p>
<pre><code class='prettyprint ruby'># sem conversa
raise

# adicionando uma string…
raise "Missing name" if name.nil?

if i >= myNames.size
  raise IndexError, "#{i} >= size (#{myNames.size})"
end

# passando o stackTrace via Kernel::caller
raise ArgumentError, "Name too big", caller
</code></pre></div>
      <div class='step' >
    
<h1>Especializando Exceções</h1>

<p>Declaração</p>
<pre><code class='prettyprint ruby'>class RetryException < RuntimeError
  attr :okToRetry

  def initialize(okToRetry)
    @okToRetry = okToRetry
  end
end
</code></pre>
<p>Como lançar</p>
<pre><code class='prettyprint ruby'>def readData(socket)
  data = socket.read(512)
  if data.nil?
    raise RetryException.new(true), "transient read error"
  end
  # .. normal processing
end
</code></pre></div>
      <div class='step' >
    
<h1>Especializando Exceções II</h1>

<p>Tratanto a exceção</p>
<pre><code class='prettyprint ruby'>begin
  stuff = readData(socket)
  # .. process stuff
rescue RetryException => detail
  retry if detail.okToRetry
  raise
end
</code></pre></div>
      <div class='step' >
    
<h1>Catch e Throw</h1>

<p>Desvio incondicional com labels</p>
<pre><code class='prettyprint ruby'>def promptAndGet(prompt)
  print prompt
  res = readline.chomp
  throw :quitRequested if res == "!"
  return res
end

catch :quitRequested do
  name = promptAndGet("Name: ")
  age  = promptAndGet("Age:  ")
  sex  = promptAndGet("Sex:  ")
  # ..
  # process information
end
</code></pre></div>
      <div class='step' >
    
<h1>Módulos</h1>

<p>Uso</p>
<pre><code class='prettyprint ruby'>### Criar namespace (evitar conflito de nomes)
### Mixin (permitir herança de traços – como se fosse uma cópia do conteúdo do módulo no local incluído)
</code></pre></div>
      <div class='step' >
    
<h1>Módulos II</h1>

<h2>Declaração</h2>
<pre><code class='prettyprint ruby'>module Trig
  PI = 3.141592654
  def Trig.sin(x)
   # ..
  end
  def Trig.cos(x)
   # ..
  end
end
</code></pre>
<h2>Uso</h2>
<pre><code class='prettyprint ruby'>require "./trig"
puts Trig.sin(Trig::PI / 3.0)
</code></pre></div>
      <div class='step' >
    
<h1>Mixins</h1>

<p>Applying mixin</p>
<pre><code class='prettyprint ruby'># BigInteger estende Number
class BigInteger < Number

  # Adiciona métodos de instância de Stringify
  include Stringify

  # Adiciona métodos de classe de Math
  extend Math

  # Adiciona um constructor com um parâmetro
  def initialize(value)
    @value = value
  end
end
</code></pre></div>
      <div class='step' >
    
<h1>Mixins II</h1>

<p>Applying mixin</p>
<pre><code class='prettyprint ruby'># Cria um novo objeto
bigint1 = BigInteger.new(10)

# Chama um método herdado da classe base
puts bigint1.intValue   # --> 10

# Chama um método de classe estendido de Math
bigint2 = BigInteger.add(-2, 4)
puts bigint2.intValue   # --> 2

# Chama um método incluído de Stringify
puts bigint2.stringify   # --> 'Two'

# Adiciona os métodos de módulo para a instância desse objeto somente
bigint2.extend CurrencyFormatter
</code></pre></div>
      <div class='step' >
    
<h1>ERB</h1>

<ul>
<li>Sistema de Template padrão do Ruby</li>
<li>Uma classe como outra qualquer</li>
<li>Via linha de comando é possível parsear um arquivo erb</li>
</ul>
</div>
      <div class='step' >
    
<h1>Dojos</h1>

<h2>Escrever um programa em Ruby que:</h2>

<ul>
<li>1 - Calcule os valores da sequência abaixo</li>
<li>2 - Calcule os valores que maximizam o tamanho da sequência</li>
</ul>

      </div>
    <script src="js/impress.js"></script>
    <script>impress().init();</script>
  </body>
</html>
    