<!DOCTYPE html>
<html>
  <head>
    <link href="css/reset.css" rel="stylesheet" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1024" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link rel="shortcut icon" href="css/favicon.png" />
    <link rel="apple-touch-icon" href="css/apple-touch-icon.png" />
    <!-- Code Prettifier: -->
<link href="css/highlight.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

    <link href="css/style.css" rel="stylesheet" />
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|PT+Sans:400,700,400italic,700italic|PT+Serif:400,700,400italic,700italic" rel="stylesheet" />
  </head>

  <body>
  <div class="fallback-message">
  <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
  <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
  </div>
    <div id="impress">
    <div class='step' >
    
<h1>Sumário</h1>

<ul>
<li>  Estruturas Básicas</li>
<li>  Estruturas de Controle</li>
<li>  Containers, Blocos e Iterators</li>
<li>  Classe, Objetos e Variáveis</li>
<li>  Mais sobre Métodos</li>
<li>  Tratamento de Exceções</li>
<li>  Módulos</li>
<li>  Pacotes básicos</li>
<li>  ERB (templates em ruby)</li>
<li>  Dojo</li>
</ul>
</div>
      <div class='step'  data-x="1000" data-scale="2">
    
<h1>Introducao:Ruby.new</h1>

<ul>
<li><p>Instalação</p>
<pre><code class='prettyprint '>apt-get install ruby
</code></pre></li>
<li><p>Editores</p>
<pre><code class='prettyprint '>TextMate Vim Sublime Emacs Aptana
</code></pre></li>
<li><p>Executando</p>
<pre><code class='prettyprint '>ruby nome_do_programa

irb  ou >> ruby interativo
</code></pre></li>
</ul>
</div>
      <div class='step' >
    
<h1>Introducao: Ruby.new</h1>

<ul>
<li><p>Linguagem para humanos</p></li>
<li><p>Compare:</p>
<pre><code class='prettyprint '>5.times { print "Ola!" }

for (int i=0; i <10; i++) { printf("Ola!");}
</code></pre></li>
</ul>
</div>
      <div class='step' >
    
<h1>Introducao: Ruby.new</h1>

<ul>
<li><p>O que faz o código a seguir?</p>
<pre><code class='prettyprint '>exit unless "restaurante".include? "aura"

[‘toasty', ’cheese', ’wine'].each 
{ |food| print food.capitalize }
</code></pre></li>
</ul>
</div>
      <div class='step'  data-x="1000" data-scale="2">
    
<h1>Estruturas básicas</h1>

<ul>
<li><p>Variáveis</p>
<pre><code class='prettyprint '>x, y, taxa_do_lixo2
</code></pre></li>
<li><p>Numeros</p>
<pre><code class='prettyprint '>1, -1.2, 6.03e-23    
</code></pre></li>
<li><p>String</p>
<pre><code class='prettyprint '>"alguma coisa assim"
%q(veremos outras formas de declarar strings)
</code></pre></li>
</ul>
</div>
      <div class='step' >
    
<h1>Estruturas basicas</h1>

<ul>
<li><p>Symbols</p>
<pre><code class='prettyprint '>:x, :y, :isso_parece_uma_string
</code></pre></li>
<li><p>Constantes</p>
<pre><code class='prettyprint '>EmpireStateBuilding, NEA, PI
</code></pre></li>
<li><p>Objetos especiais</p>
<pre><code class='prettyprint '>true, false, nil
</code></pre></li>
</ul>

<p>Símbolos são alocados uma única vez: :a.object_id durante uma execução
sempre retornara o mesmo valor. Isso nao acontece com string. O método
equal? so devolve true se dois objetos são de fato o mesmo objeto (e
instâncias da mesma classe com valores iguais).</p>
</div>
      <div class='step' >
    
<h1>Metodos (mensagens)</h1>
<pre><code class='prettyprint '>i = 1        
texto = "um texto"; puts texto
a = b = c = 0
1 == 2           # sugar syntax!!!
# metodo de classe
1.methods  # lista todos os metodos daquele objeto
1.send(:even?) # outra forma de enviar mensagens
def fibo(n = 1)
    fibo(n-2) + fibo(n-1) if n >= 2
end
def self.log
  puts "metodo de classe"
end
</code></pre>
<p>Lembre-se ... voce pode redefinir um método Quase tudo e objeto</p>
</div>
      <div class='step' >
    
<h1>Estruturas de Controle - if</h1>

<h2>Exemplo Completo</h2>
<pre><code class='prettyprint '>if count > 10
  puts "Try again"
elsif tries == 3
  puts "You lose"
else
  puts  "Number:"
end
</code></pre>
<h2>Exemplo Simples</h2>
<pre><code class='prettyprint '>if radiation > 3000
  puts "Danger"
end
</code></pre>
<h2>Modificador de Sentenca</h2>
<pre><code class='prettyprint '>puts "Danger, Will Robinson" if radiation > 3000
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas de Controle - case</h1>
<pre><code class='prettyprint '>print "Enter your grade: "
grade = gets.chomp
case grade
when "A"
  puts 'Well done!'
when "B"
  puts 'Try harder!'
when "C", "D"
  puts 'You need help!!!'
  puts "You just making it up!"
else
puts "You just making it up!"
 end
</code></pre></div>
      <div class='step' >
    
<h1>Estruturas de Controle - while</h1>
<pre><code class='prettyprint '>while weight < 100 and numPallets <= 30
  pallet = nextPallet()
  weight += pallet.weight
  numPallets += 1
end
</code></pre>
<h2>Modificador de Sentenca</h2>
<pre><code class='prettyprint '>square = square*square  while square < 1000
</code></pre></div>
      <div class='step' >
    
<h1>Estrutura de Controle - for</h1>
<pre><code class='prettyprint '>for i in 0..5
   puts "Value is #{i}"
end
</code></pre></div>
      <div class='step' >
    
<h1>Estrutura de Controle - until</h1>
<pre><code class='prettyprint '>until weight >= 100 ||numPallets > 30
  pallet = nextPallet()
  weight += pallet.weight
  numPallets += 1
end
</code></pre>
<h2>Modificador de Sentenca</h2>
<pre><code class='prettyprint '>square = square*square  until square >= 1000
</code></pre></div>
      <div class='step' >
    
<h1>Containers - Array</h1>
<pre><code class='prettyprint '>a = [ 3.14159, "pie", 99 ]
a.type   #        Array
a.length #        3
a[0]     #        3.14159
a << 1
a[3]     #        1
a[-2]    #        99
b = Array.new
b << a   #   [[3.14159, "pie", 99, 1]]
b[0..3] = a    #   [3.14159, "pie", 99, 1]
b[0, 2] = 1    #   [1, 1]
c = %w{a b c d e }  #  =>  ["a", "b", "c", "d"]
</code></pre></div>
      <div class='step' >
    
<h1>Containers - Hash</h1>
<pre><code class='prettyprint '>h = {'dog' => 'canine', 'cat' => 'feline', 'donkey' => 'asinine'}
h.length        #        3
h['dog']        #        "canine"
h['cow'] = 'bovine'
h[12]    = 'dodecine'
h['cat'] = 99
h        # => {"cow"=>"bovine", "cat"=>99, 12=>"dodecine",
"donkey"=>"asinine", "dog"=>"canine"}

a = [[1, 'a'],[2, 'b'],[3, 'c'], [4, 'd']]
b = Hash[a]
# => {1=>"a", 2=>"b", 3=>"c", 4=>"d"}
</code></pre></div>
      <div class='step' >
    
<h1>Blocos e Iteradores</h1>

<p>Passando blocos</p>
<pre><code class='prettyprint '>(1..12).each { |i| puts i}  #or
[1, 2, 4].each do |i|
    puts i
end
</code></pre>
<p>Blocos de codigo</p>
<pre><code class='prettyprint '>(1..20).each{|x| puts x}
</code></pre>
<p>Influencia do Smalltalk:</p>
<pre><code class='prettyprint '>1 to: 20 do: [:x | x printN1]
</code></pre></div>
      <div class='step' >
    
<h1> Métodos de um Enumerable</h1>
<pre><code class='prettyprint '>all?, any?, collect, detect, each_cons, each_slice, each_with_index, entries,
enum_cons, enum_slice, enum_with_index, find, find_all, grep, include?, inject,
map, max, member?, min, partition, reject, select, sort, sort_by, to_a,
to_set, zip
</code></pre></div>
      <div class='step' >
    
<h1>Exemplos com Enumeraveis</h1>
<pre><code class='prettyprint '>names = %w{ Frye Leela Zoidberg }
names.find {|name|  name.length>4}          # => "Leela"
names.find_all { |name| name.length > 4}
                                 #=> ["Leela", "Zoidberg"]
names.grep /oidberg/
# => ["Zoidberg"]
names.group_by {|name|  name.length}
   # =>  {4=>["Frye"], 5=>["Leela"], 8=>["Zoidberg"]}
</code></pre></div>
      <div class='step' >
    
<h1>Mais exemplos com Enumeraveis</h1>
<pre><code class='prettyprint '>names = %w{ Frye Leela Zoidberg }
names.map {|name| name.downcase}
# => ["frye", "leela", "zoidberg"]
names.reduce {|acc, name| name.length <= 5 ? acc + name : acc }
# => "FryeLeela"
names.join ", "
# => "Frye, Leela, Zoidberg"
</code></pre></div>
      <div class='step' >
    
<h1>Invocando blocos</h1>
<pre><code class='prettyprint '>def proxy_method
  puts "Calling command at: #{Time.new}"
  yield
proxy_method { puts "hello world proxified! "}
#ou com paremtros
def proxy_method
   yield(Time.new)
proxy_method {|time| puts "hello world proxified  at #{time}"}
</code></pre></div>
      <div class='step' >
    
<h1>Invocando blocos II</h1>
<pre><code class='prettyprint '>def proxy_method(&method)
  # argumento com & precisa ser o ultimo da lista
  puts "Calling command at: #{Time.new}"
  method.call
end
proxy_method { puts "hello world proxified! "}
#ou com paremtros
def proxy_method (&method)
   method.call(Time.new)
end
proxy_method {|time| puts "hello world proxified  at #{time}"}
</code></pre></div>
      <div class='step' >
    
<h1>Proc x Lambda</h1>
<pre><code class='prettyprint '>fx = Proc.new {|x| x**2}
fxy = proc {|x,y| x+y}
# calling
fx.call(2) # => 4
fxy[2,3,4] #=> 5
fx = lambda {|x| x**2}
fxy = lambda {|x,y| x+y}
# calling
fx.call(2) # => 4
fxy.call(2,3,4) #=> exception na cara!
Proc.new e proc sao equivalentes
</code></pre></div>
      <div class='step' >
    
<h1>Lambda “Calculus”</h1>
<pre><code class='prettyprint '>def d(f)
   lambda {|a|
     h = 0.0000000001 # um valor pequeno para h
     h = h * a       if a < 1 && 0 < a
     (f[a+h]-f[a])/h
   }
f = lambda {|x| x**2}
puts d(f)[4]
</code></pre></div>
      <div class='step' >
    
<h1>Objetos em Ruby</h1>
<pre><code class='prettyprint '>class BookInStock
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end

  def to_s
    "ISBN:#{@isbn}, price: #{@price}"
  end
end
stock = BookInStock.new
# ou
stock = BookInStock.new (1234, 10.39)
#invocando metodo
puts stock.to_s
</code></pre></div>
      <div class='step' >
    
<h1>Variaveis e Escopo</h1>

<p>l | c | r</p>

<p>Variáveis Locais &amp; <code class='inline prettyprint'>x name thx1138 _x _26</code>\
Variáveis de Instancia &amp; <code class='inline prettyprint'>@name @X  @_ @plan9</code>\
Variáveis de Classe &amp; <code class='inline prettyprint'>@@total @@N @@x_pos</code>\
Variáveis Globais &amp; <code class='inline prettyprint'>$debug $CUSTOM $_ $plan9</code>\
Nomes de Classe &amp; <code class='inline prettyprint'>String BigDecimal</code>\
Constants &amp; <code class='inline prettyprint'>FEET_PER_MILE DEBUG</code></p>
</div>
      <div class='step' >
    
<h1>Atributos de instância - forma tradicional</h1>
<pre><code class='prettyprint '>class BookInStock  
  def isbn
    @isbn
  end

  def isbn=(value)
    @isbn = value
  end

  def price
    @price
  end
</code></pre></div>
      <div class='step' >
    
<h1>Atributos de instância - forma declarativa</h1>
<pre><code class='prettyprint '>class BookInStock  
  attr_accessor :isbn
  attr_reader :price
 end
</code></pre></div>
      <div class='step' >
    
<h1>Herança</h1>

<h2>Exemplo de Heranca</h2>
<pre><code class='prettyprint '>class SpecialStock < BookInStock
</code></pre></div>
      <div class='step' >
    
<h1>Herança - Singleton Pattern</h1>

<h2>forma tradicional</h2>
<pre><code class='prettyprint '>class Logger
  private_class_method :new
  @@logger = nil
  def Logger.create
    @@logger = new unless @@logger
    @@logger
  end
end
</code></pre></div>
      <div class='step' >
    
<h2>módulo Singleton</h2>
<pre><code class='prettyprint '>require 'singleton'
class Logger
  include Singleton

  def initialize
    @log = File.open("log.txt", "a")
  end
  def log(msg)
    @log.puts(msg)
  end
Logger.instance.log('message 2')

stock =  BookInStock.new
class << stock
   def alter_price
         price * 1.4
   end
</code></pre></div>
      <div class='step' >
    
<h1>Eigenclass</h1>
<pre><code class='prettyprint '>stock =  BookInStock.new
class << stock
   def alter_price
         price * 1.4
   end
end
</code></pre></div>
      <div class='step' >
    
<h1>Criando um Enumerable (I)</h1>

<p>* Basta implementar o metodo each.</p>
<pre><code class='prettyprint '>class Node
  include Enumerable 
  attr_accessor :next, :previous, :v
 def initialize(v = {})
    @v = v
  end
 def to_s
    v.to_s
  end
</code></pre></div>
      <div class='step' >
    
<h1>Criando um Enumerable (II)</h1>
<pre><code class='prettyprint '> def <<(node)
    node.next = self.next
    node.previous = self
    self.next.previous = node unless self.next.nil?
    self.next = node
  end
 def remove
    node = self.previous
    node.next = self.next
    self.next.previous = node
    self
 end
</code></pre></div>
      <div class='step' >
    
<h1>Criando um Enumerable (III)</h1>
<pre><code class='prettyprint '>def each
    node = self.next
    until node == self || node.nil?
      yield node
      node = node.next
    end
  end
</code></pre></div>
      <div class='step' >
    
<h1>Mais sobre metodos</h1>

<p>Lista de parâmetros:</p>
<pre><code class='prettyprint '>  def myNewMethod(arg1, arg2, arg3)  # 3 arguments
    # Code for the method would go here
  end

  def myOtherNewMethod               # No arguments
    # Code for the method would go here
  end

  def coolDude(arg1="Miles", arg2="Coltrane", arg3="Roach")  #defaults
    "#{arg1}, #{arg2}, #{arg3}."
  end
</code></pre></div>
      <div class='step' >
    
<h1>Truques com parâmetros</h1>

<p>Aridade não definida</p>
<pre><code class='prettyprint '>  def varargs(arg1, *rest)
    "Got #{arg1} and #{rest.join(', ')}"
  end

  varargs("one")  # "Got one and "
  varargs("one", "two") # "Got one and two"
  varargs "one", "two", "three" # "Got one and two, three”

  def varargs(arg1, hash)
   puts “#{arg1} - #{hash}”
  end

  varargs (1, :a => 1)
</code></pre></div>
      <div class='step' >
    
<h1>Array para argumentos</h1>

<p>Expandindo array para parâmetros</p>
<pre><code class='prettyprint '>  def five(a, b, c, d, e) 
    "I was passed #{a} #{b} #{c} #{d} #{e}"
  end
  five(1, 2, 3, 4, 5 )         #  "I was passed 1 2 3 4 5"
  five(1, 2, 3, *['a', 'b'])  # "I was passed 1 2 3 a b"
  five(*(10..14).to_a)         #  "I was passed 10 11 12 13 14"
</code></pre></div>
      <div class='step' >
    
<h1>Proc para bloco</h1>

<p>Convertendo proc para bloco</p>
<pre><code class='prettyprint '>  print "(t)imes or (p)lus: "
  times = gets
  print "number: "
  number = gets.to_i

  if times =~ /^t/
    calc = proc { |n| n*number }
  else
    calc = proc { |n| n+number }
  end
  puts((1..10).collect(&calc).join(", "))
</code></pre></div>
      <div class='step' >
    
<h1>Exceptions, Catch and Throw</h1>
<pre><code class='prettyprint '>  opFile = File.open(opName, "w")
  while data = socket.read(512)
    opFile.write(data)
  end
</code></pre></div>
      <div class='step' >
    
<h1>Exceptions</h1>
<pre><code class='prettyprint '>  opFile = File.open(opName, "w")
  begin
    # Exceptions raised by this code will
    # be caught by the following rescue clause
    while data = socket.read(512)
      opFile.write(data)
    end

  rescue SystemCallError
    $stderr.print "IO failed: " + $!
    opFile.close
    File.delete(opName)
    raise
  end
</code></pre></div>
      <div class='step' >
    
<h1>Catching exception</h1>

<p>Nomeando a exceção</p>
<pre><code class='prettyprint '>   begin
    eval string
  rescue SyntaxError, NameError => boom
    #OLHA! sem usar o $!
    print "String doesn't compile: " + boom
  rescue StandardError => bang
    print "Error running script: " + bang
  end
</code></pre></div>
      <div class='step' >
    
<h1>Ensure</h1>

<p>Garante que um bloco é chamado</p>
<pre><code class='prettyprint '>  f = File.open("testfile")
  begin
    # .. process
  rescue
    # .. handle error
  ensure
    f.close unless f.nil?
  end
</code></pre></div>
      <div class='step' >
    
<h1>Rescuing a Method</h1>

<p>Begin Rescue</p>
<pre><code class='prettyprint '>  def some_method
    begin
      danger_danger
      true # good return
    rescue Error
      false # error return
    end
  end
</code></pre>
<p>Better code</p>
<pre><code class='prettyprint '>  def some_method
    danger_danger
    true # good response
  rescue Error
    false # error response
  end
</code></pre></div>
      <div class='step' >
    
<h1>Raise Exceptions</h1>

<p>Formas típicas de se lançar uma exceção</p>
<pre><code class='prettyprint '>  # sem conversa
  raise

  # adicionando uma string…
  raise "Missing name" if name.nil?

  if i >= myNames.size
    raise IndexError, "#{i} >= size (#{myNames.size})"
  end

  # passando o stackTrace via Kernel::caller
  raise ArgumentError, "Name too big", caller
</code></pre></div>
      <div class='step' >
    
<h1>Especializando Exceções</h1>

<p>Declaração</p>
<pre><code class='prettyprint '>  class RetryException < RuntimeError
    attr :okToRetry
    def initialize(okToRetry)
      @okToRetry = okToRetry
    end
  end
</code></pre>
<p>Como lançar</p>
<pre><code class='prettyprint '>  def readData(socket)
    data = socket.read(512)
    if data.nil?
      raise RetryException.new(true), "transient read error"
    end
    # .. normal processing
  end
</code></pre></div>
      <div class='step' >
    
<h1>Especializando Exceções II</h1>

<p>Tratanto a exceção</p>
<pre><code class='prettyprint '>  begin
    stuff = readData(socket)
    # .. process stuff
  rescue RetryException => detail
    retry if detail.okToRetry
    raise
  end
</code></pre></div>
      <div class='step' >
    
<h1>Catch e Throw</h1>

<p>Desvio incondicional com labels</p>
<pre><code class='prettyprint '>  def promptAndGet(prompt)
    print prompt
    res = readline.chomp
    throw :quitRequested if res == "!"
    return res
  end

  catch :quitRequested do
    name = promptAndGet("Name: ")
    age  = promptAndGet("Age:  ")
    sex  = promptAndGet("Sex:  ")
    # ..
    # process information
  end
</code></pre></div>
      <div class='step' >
    
<h1>Módulos</h1>

<p>Uso</p>

<h3>Criar namespace (evitar conflito de nomes)</h3>

<h3>Mixin (permitir herança de traços – como se fosse uma cópia do conteúdo do módulo no local incluído)</h3>
</div>
      <div class='step' >
    
<h1>Módulos II</h1>

<h2>Declaração</h2>
<pre><code class='prettyprint '>  module Trig
    PI = 3.141592654
    def Trig.sin(x)
     # ..
    end
    def Trig.cos(x)
     # ..
    end
  end
</code></pre>
<h2>Uso</h2>
<pre><code class='prettyprint '>  require "./trig"
  puts Trig.sin(Trig::PI / 3.0)
</code></pre></div>
      <div class='step' >
    
<h1>Mixins</h1>

<p>Applying mixin</p>
<pre><code class='prettyprint '>  # BigInteger estende Number
  class BigInteger < Number

    # Adiciona métodos de instância de Stringify
    include Stringify

    # Adiciona métodos de classe de Math
    extend Math

    # Adiciona um constructor com um parâmetro
    def initialize(value)
      @value = value
    end
  end
</code></pre></div>
      <div class='step' >
    
<h1>Mixins II</h1>

<p>Applying mixin</p>
<pre><code class='prettyprint '>  # Cria um novo objeto
  bigint1 = BigInteger.new(10)

  # Chama um método herdado da classe base
  puts bigint1.intValue   # --> 10

  # Chama um método de classe estendido de Math
  bigint2 = BigInteger.add(-2, 4)
  puts bigint2.intValue   # --> 2

  # Chama um método incluído de Stringify
  puts bigint2.stringify   # --> 'Two'

  # Adiciona os métodos de módulo para a instância desse objeto somente
  bigint2.extend CurrencyFormatter
</code></pre></div>
      <div class='step' >
    
<h1>ERB</h1>

<ul>
<li>Sistema de Template padrão do Ruby</li>
<li>Uma classe como outra qualquer</li>
<li>Via linha de comando é possível parsear um arquivo erb</li>
</ul>
</div>
      <div class='step' >
    
<h1>Dojo</h1>

<h2>Escrever um programa em Ruby que:</h2>

<ul>
<li>1 - Calcule os valores da sequência abaixo</li>
<li>2 - Calcule os valores que maximizam o tamanho da sequência</li>
</ul>

      </div>
    <script src="js/impress.js"></script>
    <script>impress().init();</script>
  </body>
</html>
    